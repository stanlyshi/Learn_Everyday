/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:45 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "performanceInfoGroup.h"

/*
 * performanceInfoGroup_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             performanceInfoGroup_variables_oid[] =
    { 1, 3, 6, 1, 4, 1, 1, 2, 4 };

/*
 * variable4 performanceInfoGroup_variables:
 *   this variable defines function callbacks and type return information 
 *   for the performanceInfoGroup mib section 
 */

struct variable4 performanceInfoGroup_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */

#define CELLPERFINFOCELLGLOBALID		1
    {CELLPERFINFOCELLGLOBALID, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 1}},
#define CELLPERFINFOPHYULTHROUGHTPUT		2
    {CELLPERFINFOPHYULTHROUGHTPUT, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 2}},
#define CELLPERFINFOPHYDLTHROUGHTPUT		3
    {CELLPERFINFOPHYDLTHROUGHTPUT, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 3}},
#define CELLPERFINFOPHYSNMIN		4
    {CELLPERFINFOPHYSNMIN, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 4}},
#define CELLPERFINFOPHYSNMAX		5
    {CELLPERFINFOPHYSNMAX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 5}},
#define CELLPERFINFOPHYULVOL		6
    {CELLPERFINFOPHYULVOL, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 6}},
#define CELLPERFINFOPHYDLVOL		7
    {CELLPERFINFOPHYDLVOL, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 7}},
#define CELLPERFINFOMACULRATE		8
    {CELLPERFINFOMACULRATE, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 8}},
#define CELLPERFINFOMACDLRATE		9
    {CELLPERFINFOMACDLRATE, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 9}},
#define CELLPERFINFORLCULRATE		10
    {CELLPERFINFORLCULRATE, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 10}},
#define CELLPERFINFORLCDLRATE		11
    {CELLPERFINFORLCDLRATE, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 11}},
#define CELLPERFINFORLCBUFDATA		12
    {CELLPERFINFORLCBUFDATA, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 12}},
#define CELLPERFINFOPDCPULRATE		13
    {CELLPERFINFOPDCPULRATE, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 13}},
#define CELLPERFINFOPDCPDLRATE		14
    {CELLPERFINFOPDCPDLRATE, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 14}},
#define CELLPERFINFOERRBLKRATE		15
    {CELLPERFINFOERRBLKRATE, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 15}},
#define CELLPERFINFOBANDWIDTHOCCUPANCY		16
    {CELLPERFINFOBANDWIDTHOCCUPANCY, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 16}},
#define CELLPERFINFOUEONS		17
    {CELLPERFINFOUEONS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 17}},
#define CELLPERFINFOUEOFFS		18
    {CELLPERFINFOUEOFFS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 18}},
#define CELLPERFINFOUEACCESSSUCCRATE		19
    {CELLPERFINFOUEACCESSSUCCRATE, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellPerfInfoTable, 3, {1, 1, 19}},
};

/*
 * (L = length of the oidsuffix) 
 */


/** Initializes the performanceInfoGroup module */
void
init_performanceInfoGroup(void)
{

    DEBUGMSGTL(("performanceInfoGroup", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("performanceInfoGroup", performanceInfoGroup_variables,
                 variable4, performanceInfoGroup_variables_oid);

    /*
     * place any other initialization junk you need here 
     */
}

/*
 * var_performanceInfoGroup():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_performanceInfoGroup(struct variable *vp,
                         oid * name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_cellPerfInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_performanceInfoGroup above.
 */
unsigned char  *
var_cellPerfInfoTable(struct variable *vp,
                      oid * name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CELLPERFINFOCELLGLOBALID:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOPHYULTHROUGHTPUT:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOPHYDLTHROUGHTPUT:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOPHYSNMIN:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOPHYSNMAX:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOPHYULVOL:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOPHYDLVOL:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOMACULRATE:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOMACDLRATE:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFORLCULRATE:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFORLCDLRATE:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFORLCBUFDATA:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOPDCPULRATE:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOPDCPDLRATE:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOERRBLKRATE:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOBANDWIDTHOCCUPANCY:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOUEONS:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOUEOFFS:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLPERFINFOUEACCESSSUCCRATE:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}
