/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:45 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cellMgmtGroup.h"

#include<signal.h>

/**
 *	管理项名称	含义	数据类型	OID值	备注
 *	cellMgmtConfigInfoCellGlobalID	小区全局ID（此表索引）	Integer32	1.3.6.1.4.1.1.2.2.1.1.1	
 *	cellMgmtConfigInfoCellDescribe	小区描述	DisplayString	1.3.6.1.4.1.1.2.2.1.1.2	
 *	cellMgmtConfigInfoCellMode	小区制式	JtSranCellMode	1.3.6.1.4.1.1.2.2.1.1.3	
 *	cellMgmtConfigInfoCellType	小区类型	JtSranCellType	1.3.6.1.4.1.1.2.2.1.1.4	
 *	cellMgmtConfigInfoCellRole	小区角色	JtSranCellRole	1.3.6.1.4.1.1.2.2.1.1.5	
 *	cellMgmtConfigInfoRRUSN	小区RRU序列号	OCTET STRING	1.3.6.1.4.1.1.2.2.1.1.6	
 *	cellMgmtConfigInfoRRUID	小区RRU ID	Integer32	1.3.6.1.4.1.1.2.2.1.1.7	
 *	cellMgmtConfigInfoRRUIP	非一体化小区RRU侧OM IP地址	IpAddress	1.3.6.1.4.1.1.2.2.1.1.8	
 *	cellMgmtConfigInfoRRUPort	非一体化小区RRU侧OM Port	Integer32	1.3.6.1.4.1.1.2.2.1.1.9	
 *	cellMgmtConfigInfoPowerFactor	小区功率因子	Integer32	1.3.6.1.4.1.1.2.2.1.1.10	
 *	cellMgmtConfigInfoBBUIP	非一体化小区BBU侧OM IP地址	IpAddress	1.3.6.1.4.1.1.2.2.1.1.11	
 *	cellMgmtConfigInfoBBUPort	非一体化小区BBU侧OM Port	Integer32	1.3.6.1.4.1.1.2.2.1.1.12	
 *	cellMgmtConfigInfoCellPerfOnOff	小区性能查询开关	TruthValue	1.3.6.1.4.1.1.2.2.1.1.13	
 *	cellMgmtConfigInfoRowStatus	Row状态	RowStatus	1.3.6.1.4.1.1.2.2.1.1.14	
 *
 */
/**
 * 管理项名称	数据类型	OID值	备注
 * cellMgmtConfigInfoCellGlobalID	Integer32	1.3.6.1.4.1.1.2.2.1.1.1	
 * cellMgmtConfigInfoCellDescribe	DisplayString	1.3.6.1.4.1.1.2.2.1.1.2	
 * cellMgmtConfigInfoCellMode	JtSranCellMode	1.3.6.1.4.1.1.2.2.1.1.3	
 * cellMgmtConfigInfoCellType	JtSranCellType	1.3.6.1.4.1.1.2.2.1.1.4	
 * cellMgmtConfigInfoCellRole	JtSranCellRole	1.3.6.1.4.1.1.2.2.1.1.5	
 * cellMgmtConfigInfoRRUSN	OCTET STRING	1.3.6.1.4.1.1.2.2.1.1.6	
 * cellMgmtConfigInfoRRUID	Integer32	1.3.6.1.4.1.1.2.2.1.1.7	
 * cellMgmtConfigInfoRRUIP	IpAddress	1.3.6.1.4.1.1.2.2.1.1.8	
 * cellMgmtConfigInfoRRUPort	Integer32	1.3.6.1.4.1.1.2.2.1.1.9	
 * cellMgmtConfigInfoPowerFactor	Integer32	1.3.6.1.4.1.1.2.2.1.1.10	
 * cellMgmtConfigInfoBBUIP	IpAddress	1.3.6.1.4.1.1.2.2.1.1.11	
 * cellMgmtConfigInfoBBUPort	Integer32	1.3.6.1.4.1.1.2.2.1.1.12	
 * cellMgmtConfigInfoCellPerfOnOff	TruthValue	1.3.6.1.4.1.1.2.2.1.1.13	
 * cellMgmtConfigInfoRowStatus	RowStatus	1.3.6.1.4.1.1.2.2.1.1.14	
 *
 */
/*
 * cellMgmtGroup_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             cellMgmtGroup_variables_oid[] =
    { 1, 3, 6, 1, 4, 1, 1, 2, 2 };

/*
 * variable4 cellMgmtGroup_variables:
 *   this variable defines function callbacks and type return information 
 *   for the cellMgmtGroup mib section 
 */

struct variable4 cellMgmtGroup_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */

#define CELLMGMTCONFIGINFOCELLGLOBALID		1
    {CELLMGMTCONFIGINFOCELLGLOBALID, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 1}},
#define CELLMGMTCONFIGINFOCELLDESCRIBE		2
    {CELLMGMTCONFIGINFOCELLDESCRIBE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 2}},
#define CELLMGMTCONFIGINFOCELLMODE		3
    {CELLMGMTCONFIGINFOCELLMODE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 3}},
#define CELLMGMTCONFIGINFOCELLTYPE		4
    {CELLMGMTCONFIGINFOCELLTYPE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 4}},
#define CELLMGMTCONFIGINFOCELLROLE		5
    {CELLMGMTCONFIGINFOCELLROLE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 5}},
#define CELLMGMTCONFIGINFORRUSN		6
    {CELLMGMTCONFIGINFORRUSN, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 6}},
#define CELLMGMTCONFIGINFORRUID		7
    {CELLMGMTCONFIGINFORRUID, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 7}},
#define CELLMGMTCONFIGINFORRUIP		8
    {CELLMGMTCONFIGINFORRUIP, ASN_IPADDRESS, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 8}},
#define CELLMGMTCONFIGINFORRUPORT		9
    {CELLMGMTCONFIGINFORRUPORT, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 9}},
#define CELLMGMTCONFIGINFOPOWERFACTOR		10
    {CELLMGMTCONFIGINFOPOWERFACTOR, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 10}},
#define CELLMGMTCONFIGINFOBBUIP		11
    {CELLMGMTCONFIGINFOBBUIP, ASN_IPADDRESS, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 11}},
#define CELLMGMTCONFIGINFOBBUPORT		12
    {CELLMGMTCONFIGINFOBBUPORT, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 12}},
#define CELLMGMTCONFIGINFOCELLPERFONOFF		13
    {CELLMGMTCONFIGINFOCELLPERFONOFF, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 13}},
#define CELLMGMTCONFIGINFOROWSTATUS		14
    {CELLMGMTCONFIGINFOROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cellMgmtConfigInfoTable, 3, {1, 1, 14}},
};

/*
 * (L = length of the oidsuffix) 
 */


/** Initializes the cellMgmtGroup module */
void
init_cellMgmtGroup(void)
{

    DEBUGMSGTL(("cellMgmtGroup", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("cellMgmtGroup", cellMgmtGroup_variables, variable4,
                 cellMgmtGroup_variables_oid);

    /*
     * place any other initialization junk you need here 
     */
}

/*
 * var_cellMgmtGroup():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_cellMgmtGroup(struct variable *vp,
                  oid * name,
                  size_t *length,
                  int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_cellMgmtConfigInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_cellMgmtGroup above.
 */
unsigned char  *
var_cellMgmtConfigInfoTable(struct variable *vp,
                            oid * name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    /**
	 *	Define
	 */
	static int TABLE_SIZE = 10;
	static int VAR = 1, VALUE = 2;
    
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CELLMGMTCONFIGINFOCELLGLOBALID:
        log_mibs_debug();
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFOCELLDESCRIBE:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoCellDescribe;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFOCELLMODE:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoCellMode;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFOCELLTYPE:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoCellType;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFOCELLROLE:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoCellRole;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFORRUSN:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoRRUSN;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFORRUID:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoRRUID;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFORRUIP:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoRRUIP;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFORRUPORT:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoRRUPort;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFOPOWERFACTOR:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoPowerFactor;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFOBBUIP:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoBBUIP;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFOBBUPORT:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoBBUPort;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFOCELLPERFONOFF:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoCellPerfOnOff;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case CELLMGMTCONFIGINFOROWSTATUS:
        log_mibs_debug();
        *write_method = write_cellMgmtConfigInfoRowStatus;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    default:
        log_mibs_debug();
        ERROR_MSG("");
    }
    return NULL;
}


int
write_cellMgmtConfigInfoCellDescribe(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoCellMode(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoCellType(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoCellRole(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoRRUSN(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoRRUID(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoRRUIP(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    in_addr_t       value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(in_addr_t)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(in_addr_t *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoRRUPort(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoPowerFactor(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoBBUIP(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    in_addr_t       value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(in_addr_t)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(in_addr_t *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoBBUPort(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoCellPerfOnOff(int action,
                                      u_char * var_val,
                                      u_char var_val_type,
                                      size_t var_val_len,
                                      u_char * statP,
                                      oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cellMgmtConfigInfoRowStatus(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cellMgmtGroup not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cellMgmtGroup: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}




int main(int argc, char *argv[])
{
    /* change this if you want to be a SNMP master agent */
    int agentx_subagent = 1;
    /* change this if you want to run in the background */
    int background = 0;
    /* change this if you want to use syslog */
    int syslog_enable = 0;
    int snmp_pdu_max_size = -1;
    struct sigaction act;
    if (syslog_enable)
    {
      snmp_enable_calllog ();
    }
    else
    {
      snmp_enable_stderrlog ();
    }
    /* Being an agentX subAgent */
    if (agentx_subagent)
    {
      /* make us a agentX client. */
      netsnmp_ds_set_boolean (NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_ROLE,1);
    }

    /* run in background, if requested */
    if (background && netsnmp_daemonize (1, !syslog_enable))
    exit (1);

    /* Initialize TCP-IP, if NEEDED */
    SOCK_STARTUP;

    /* Master agent address */
    //netsnmp_ds_set_string (NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_X_SOCKET,
    //			 "localhost:705");/*localhost:19003 or 705*/

    /* Initialize the agent library */
    init_agent ("text");

    init_cellMgmtGroup();

    /* gsc_sub_test will be used to read gsc_sub.conf files. */
    init_snmp ("text");
    
    log_mibs_debug();
    
    while(1)
    {
        agent_check_and_process(1);
        sleep(1);
        log_mibs_debug();
    }
    
    return 0;
}
