在TCP传输数据流中，存在两种类型的TCP报文段，一种包含成块数据（通常是满长度的，携带一个报文段最多容纳的字节数），另一种则包含交互数据（通常只有携带几个字节数据）。

对于成块数据的报文段，TCP采用正常的流程发送即可，因为数据利用率很高。而对于交互数据的报文段，数据利用率就显得很低，在网络环境不好的情况下容易加重网络负担。所以TCP必须对交互数据单独处理

交互数据实际上就是字节数很少的数据，比如客户端调用10次send操作，每次只发送一个字节的数据。

Nagle算法
nagle算法用于处理小报文段（微小分组）的发送问题

nagle算法的核心思想是允许网络中最多只能有一个小分组被发送，而待发送的其它小分组会被重新分组成一个”较大的”小分组，等收到上一个小分组的应答后再发送

nagle算法可以减少网络中微小分组的数量，比如客户端需要依次向服务器发送大小为1,2,3,1,2字节的5个分组

在没有开启nagle算法的情况下，这些小分组会被依次发送（不需要等待上一个小分组的应答，因为没启动nagle），总共发送的报文段（分组）个数为5

当开启nagle算法时，客户端首先发送大小为1字节的第一个分组，随后其它分组到达发送缓冲区，由于上一个分组的应答还没有收到，所以TCP会先缓存新来的这4个小分组，并将其重新分组，组成一个大小为8(2+3+1+2)字节的”较大的”小分组。当第一个小分组的应答收到后，客户端将这个8字节的分组发送。总共发送的报文段（分组）个数为2

可以看到，当传输数据存在大量交互数据时，nagle算法可以有效减少网络中的报文段个数

下面通过wireshark抓包分析nagle算法，客户端服务器的执行流程为

建立连接
客户端将字符串”hello”发送给服务器，但是每次只发送一个字节（即连续调用5次send/write函数）
服务器收到客户端的数据后将其缓存，等到全部收到后将其发回客户端
通过wireshark观察网络中报文段的传输


不知道是操作问题还是客户端服务器处在一个主机上传输速度太快的原因，代码执行了好多次才有个别能体现nagle算法的结果

对图中结果进行分析

1-3行是三次握手
4-5行是发送字节’h’以及服务器的应答
6-7行是发送字节’e’以及服务器的应答
8-9行是发送字节’llo’以及服务器的应答
10行是服务器发送的”hello”报文段
11-14行是四次挥手
可以看到nagle算法确实将待发送的小分组重新分组，等到上一个小分组确认报文到达后一起发送

禁止Nagle
虽然nagle算法可以减少网络中小分组的个数，但是对于那些需要实时预览的通讯程序而言，客户端可能需要不断发送更新数据并得到服务器的响应，这种情况下nagle算法会造成客户端明显的延迟，所以需要禁用nagle算法

将套接字描述符设置TCP_NODELAY选项可以禁止nagle算法

#include <netinet/tcp.h>
...

void cancel_nagle(int fd)
{
    int val = 1;
    ::setsockopt(fd, SOL_TCP, TCP_NODELAY, &val, sizeof(val));
}
1
2
3
4
5
6
7
8
还是以上面的程序为例，这回将nagle算法禁止，观察wireshark抓包结果，预计客户端TCP可以连续发送小报文段而不需要等待上一个小报文段的确认


————————————————
版权声明：本文为CSDN博主「一个程序渣渣的小后院」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/sinat_35261315/article/details/79392116
