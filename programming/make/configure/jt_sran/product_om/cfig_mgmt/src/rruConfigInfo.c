/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:33 CST. */
/* 
 Copyright (C) Rong Tao @Beijing

 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.3
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
 Texts. A copy of the license is included in the section entitled ‘‘GNU
 Free Documentation License’’.
   2019年 03月 14日 星期四 19:24:45 CST. 
*/
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 08日 星期五 08:10:29 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:28:04 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <string.h>
#include "rruConfigInfo.h"
#include "cfig_common.h"
#include "sbs_type.h"
#include "sbs_log.h"
#include "rrus_mgmt_api_cfig_mgmt.h"
#include "om_common_h.h"
#include "rruInitInfo.h"
/*
 * rruConfigInfo_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static rruCfgMsgTable 		rruCfgMsgTable_RowBuf;
static rruDealyCfgTable 	rruDealyCfgTable_RowBuf;
static rruRingTestTable		rruRingTestTable_RowBuf;
static rruOperateTable		rruOperateTable_RowBuf;

void intVec2charVec(char * char_vec, int *int_vec, int len)
{
	int i = 0;
	while(i < len){
		char_vec[i] = int_vec[i] + '0';	
		i++;
	}
}



oid             rruConfigInfo_variables_oid[] =
    { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 3, 2 };

/*
 * variable4 rruConfigInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the rruConfigInfo mib section 
 */

struct variable4 rruConfigInfo_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */

#define RRULOGICMSGINDEX		1
    {RRULOGICMSGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruLogicMsgTable, 3, {1, 1, 1}},
#define RRULOGICMSGRRUID		2
    {RRULOGICMSGRRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 2}},
#define RRULOGICMSGNEID		3
    {RRULOGICMSGNEID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 3}},
#define RRULOGICMSGBBUID		4
    {RRULOGICMSGBBUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 4}},
#define RRULOGICMSGFPGAID		5
    {RRULOGICMSGFPGAID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 5}},
#define RRULOGICMSGCPRIPORT		6
    {RRULOGICMSGCPRIPORT, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 6}},
#define RRULOGICMSGBBUIP		7
    {RRULOGICMSGBBUIP, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 7}},
#define RRULOGICMSGRRUIP		8
    {RRULOGICMSGRRUIP, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 8}},
#define RRULOGICMSGRRUMAC		9
    {RRULOGICMSGRRUMAC, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 9}},
#define RRULOGICMSGSUBMASK		10
    {RRULOGICMSGSUBMASK, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 10}},
#define RRULOGICMSGROWSTATUS		11
    {RRULOGICMSGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruLogicMsgTable, 3, {1, 1, 11}},
#define RRUPRODUCTMSGINDEX		1
    {RRUPRODUCTMSGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruProductMsgTable, 3, {2, 1, 1}},
#define RRUPRODUCTMSGRRUID		2
    {RRUPRODUCTMSGRRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruProductMsgTable, 3, {2, 1, 2}},
#define RRUPRODUCTMSGMANUFACTUERE		3
    {RRUPRODUCTMSGMANUFACTUERE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruProductMsgTable, 3, {2, 1, 3}},
#define RRUPRODUCTMSGPUBLISHER		4
    {RRUPRODUCTMSGPUBLISHER, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruProductMsgTable, 3, {2, 1, 4}},
#define RRUPRODUCTMSGSERIALNO		5
    {RRUPRODUCTMSGSERIALNO, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruProductMsgTable, 3, {2, 1, 5}},
#define RRUPRODUCTMSGMANUFACTUREDATE		6
    {RRUPRODUCTMSGMANUFACTUREDATE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruProductMsgTable, 3, {2, 1, 6}},
#define RRUPRODUCTMSGLASTSERVICEDATE		7
    {RRUPRODUCTMSGLASTSERVICEDATE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruProductMsgTable, 3, {2, 1, 7}},
#define RRUPRODUCTMSGEXTRAINFO		8
    {RRUPRODUCTMSGEXTRAINFO, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruProductMsgTable, 3, {2, 1, 8}},
#define RRUPRODUCTMSGROWSTATUS		9
    {RRUPRODUCTMSGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruProductMsgTable, 3, {2, 1, 9}},
#define RRUCFGMSGINDEX		1
    {RRUCFGMSGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruCfgMsgTable, 3, {3, 1, 1}},
#define RRUCFGMSGRRUID		2
    {RRUCFGMSGRRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 2}},
#define RRUCFGMSGCPUUSAGE		3
    {RRUCFGMSGCPUUSAGE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 3}},
#define RRUCFGMSGPERIOD		4
    {RRUCFGMSGPERIOD, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 4}},
#define RRUCFGMSGTEMPVAL		5
    {RRUCFGMSGTEMPVAL, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 5}},
#define RRUCFGMSGVSWRVAL		6
    {RRUCFGMSGVSWRVAL, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 6}},
#define RRUCFGMSGVSWRTHRES1		7
    {RRUCFGMSGVSWRTHRES1, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 7}},
#define RRUCFGMSGVSWRTHRES2		8
    {RRUCFGMSGVSWRTHRES2, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 8}},
#define RRUCFGMSGPPOWERVAL		9
    {RRUCFGMSGPPOWERVAL, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 9}},
#define RRUCFGMSGUPTHRES		10
    {RRUCFGMSGUPTHRES, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 10}},
#define RRUCFGMSGLOWTHRES		11
    {RRUCFGMSGLOWTHRES, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 11}},
#define RRUCFGMSGANTMODE		12
    {RRUCFGMSGANTMODE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 12}},
#define RRUCFGMSGANTSETNO		13
    {RRUCFGMSGANTSETNO, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 13}},
#define RRUCFGMSGANTSTATE		14
    {RRUCFGMSGANTSTATE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 14}},
#define RRUCFGMSGUPPATHSTATE		15
    {RRUCFGMSGUPPATHSTATE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 15}},
#define RRUCFGMSGDWPATHSTATE		16
    {RRUCFGMSGDWPATHSTATE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 16}},
#define RRUCFGMSGSTATE		17
    {RRUCFGMSGSTATE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 17}},
#define RRUCFGMSGCLOCKSTATE		18
    {RRUCFGMSGCLOCKSTATE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 18}},
#define RRUCFGMSGROWSTATUS		19
    {RRUCFGMSGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruCfgMsgTable, 3, {3, 1, 19}},
#define RRULATESTCHANNELSETINDEX		1
    {RRULATESTCHANNELSETINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruLatestChannelSetTable, 3, {4, 1, 1}},
#define RRULATESTCHANNELSETRRUID		2
    {RRULATESTCHANNELSETRRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruLatestChannelSetTable, 3, {4, 1, 2}},
#define RRULATESTCHANNELSETREASON		3
    {RRULATESTCHANNELSETREASON, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruLatestChannelSetTable, 3, {4, 1, 3}},
#define RRULATESTCHANNELSETALARMCODE		4
    {RRULATESTCHANNELSETALARMCODE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruLatestChannelSetTable, 3, {4, 1, 4}},
#define RRULATESTCHANNELSETROWSTATUS		5
    {RRULATESTCHANNELSETROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruLatestChannelSetTable, 3, {4, 1, 5}},
#define RRUABILITYMSGINDEX		1
    {RRUABILITYMSGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruAbilityMsgTable, 3, {5, 1, 1}},
#define RRUABILITYMSGRRUID		2
    {RRUABILITYMSGRRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 2}},
#define RRUABILITYMSGTDCARRIERNUM		3
    {RRUABILITYMSGTDCARRIERNUM, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 3}},
#define RRUABILITYMSGLTECARRIERNUM		4
    {RRUABILITYMSGLTECARRIERNUM, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 4}},
#define RRUABILITYMSGANTNUM		5
    {RRUABILITYMSGANTNUM, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 5}},
#define RRUABILITYMSGMAXPOWER		6
    {RRUABILITYMSGMAXPOWER, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 6}},
#define RRUABILITYMSGMASTERORSLAVE		7
    {RRUABILITYMSGMASTERORSLAVE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 7}},
#define RRUABILITYMSGMAXDWTIMEDELAY		8
    {RRUABILITYMSGMAXDWTIMEDELAY, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 8}},
#define RRUABILITYMSGMAXUPTIMEDELAY		9
    {RRUABILITYMSGMAXUPTIMEDELAY, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 9}},
#define RRUABILITYMSGSUPPORTMODE		10
    {RRUABILITYMSGSUPPORTMODE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 10}},
#define RRUABILITYMSGANTCLBRTFLAG		11
    {RRUABILITYMSGANTCLBRTFLAG, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 11}},
#define RRUABILITYMSGMAINSENDEMEPATH		12
    {RRUABILITYMSGMAINSENDEMEPATH, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 12}},
#define RRUABILITYMSGSLAVESENDEMEPATH		13
    {RRUABILITYMSGSLAVESENDEMEPATH, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 13}},
#define RRUABILITYMSGMAINRECVEMEPATH		14
    {RRUABILITYMSGMAINRECVEMEPATH, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 14}},
#define RRUABILITYMSGSLAVERECVEMEPATH		15
    {RRUABILITYMSGSLAVERECVEMEPATH, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 15}},
#define RRUABILITYMSGROWSTATUS		16
    {RRUABILITYMSGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruAbilityMsgTable, 3, {5, 1, 16}},
#define RRUSOFTHARDMSGINDEX		1
    {RRUSOFTHARDMSGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruSoftHardMsgTable, 3, {6, 1, 1}},
#define RRUSOFTHARDMSGRRUID		2
    {RRUSOFTHARDMSGRRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruSoftHardMsgTable, 3, {6, 1, 2}},
#define RRUSOFTHARDMSGHWTYPE		3
    {RRUSOFTHARDMSGHWTYPE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruSoftHardMsgTable, 3, {6, 1, 3}},
#define RRUSOFTHARDMSGHWVERSION		4
    {RRUSOFTHARDMSGHWVERSION, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruSoftHardMsgTable, 3, {6, 1, 4}},
#define RRUSOFTHARDMSGSWVER		5
    {RRUSOFTHARDMSGSWVER, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruSoftHardMsgTable, 3, {6, 1, 5}},
#define RRUSOFTHARDMSGFWVER		6
    {RRUSOFTHARDMSGFWVER, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruSoftHardMsgTable, 3, {6, 1, 6}},
#define RRUSOFTHARDMSGROWSTATUS		7
    {RRUSOFTHARDMSGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruSoftHardMsgTable, 3, {6, 1, 7}},
#define RRUDELAYMEASUREINDEX		1
    {RRUDELAYMEASUREINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruDelayMeasureTable, 3, {7, 1, 1}},
#define RRUDELAYMEASURERRUID		2
    {RRUDELAYMEASURERRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDelayMeasureTable, 3, {7, 1, 2}},
#define RRUDELAYMEASUREFIBERNO		3
    {RRUDELAYMEASUREFIBERNO, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDelayMeasureTable, 3, {7, 1, 3}},
#define RRUDELAYMEASURETOFFSET		4
    {RRUDELAYMEASURETOFFSET, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDelayMeasureTable, 3, {7, 1, 4}},
#define RRUDELAYMEASURETBDELAYDL		5
    {RRUDELAYMEASURETBDELAYDL, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDelayMeasureTable, 3, {7, 1, 5}},
#define RRUDELAYMEASURETBDELAYUL		6
    {RRUDELAYMEASURETBDELAYUL, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDelayMeasureTable, 3, {7, 1, 6}},
#define RRUDELAYMEASURET2A		7
    {RRUDELAYMEASURET2A, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDelayMeasureTable, 3, {7, 1, 7}},
#define RRUDELAYMEASURET3A		8
    {RRUDELAYMEASURET3A, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDelayMeasureTable, 3, {7, 1, 8}},
#define RRUDELAYMEASUREROWSTATUS		9
    {RRUDELAYMEASUREROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruDelayMeasureTable, 3, {7, 1, 9}},
#define RRUDEALYCFGINDEX		1
    {RRUDEALYCFGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruDealyCfgTable, 3, {8, 1, 1}},
#define RRUDEALYCFGRRUID		2
    {RRUDEALYCFGRRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDealyCfgTable, 3, {8, 1, 2}},
#define RRUDEALYCFGFIBERNO		3
    {RRUDEALYCFGFIBERNO, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDealyCfgTable, 3, {8, 1, 3}},
#define RRUDEALYCFGTRXARXM		4
    {RRUDEALYCFGTRXARXM, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDealyCfgTable, 3, {8, 1, 4}},
#define RRUDEALYCFGTRXMRXA		5
    {RRUDEALYCFGTRXMRXA, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDealyCfgTable, 3, {8, 1, 5}},
#define RRUDEALYCFGTIMEADV		6
    {RRUDEALYCFGTIMEADV, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDealyCfgTable, 3, {8, 1, 6}},
#define RRUDEALYCFGDLCALRRU		7
    {RRUDEALYCFGDLCALRRU, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDealyCfgTable, 3, {8, 1, 7}},
#define RRUDEALYCFGULCALRRU		8
    {RRUDEALYCFGULCALRRU, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruDealyCfgTable, 3, {8, 1, 8}},
#define RRUDEALYCFGROWSTATUS		9
    {RRUDEALYCFGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruDealyCfgTable, 3, {8, 1, 9}},
#define RRURINGTESTINDEX		1
    {RRURINGTESTINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruRingTestTable, 3, {9, 1, 2}},
#define RRURINGTESTRRUID		2
    {RRURINGTESTRRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruRingTestTable, 3, {9, 1, 3}},
#define RRURINGTESTTYPE		3
    {RRURINGTESTTYPE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruRingTestTable, 3, {9, 1, 4}},
#define RRURINGTESTCHECKPERIOD		4
    {RRURINGTESTCHECKPERIOD, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruRingTestTable, 3, {9, 1, 5}},
#define RRURINGTESTPORTNO		5
    {RRURINGTESTPORTNO, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruRingTestTable, 3, {9, 1, 6}},
#define RRURINGTESTROWSTATUS		6
    {RRURINGTESTROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruRingTestTable, 3, {9, 1, 7}},
#define RRUOPERATEINDEX		1
    {RRUOPERATEINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruOperateTable, 3, {10, 1, 1}},
#define RRUOPERATERESETTYPE		2
    {RRUOPERATERESETTYPE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruOperateTable, 3, {10, 1, 2}},
#define RRUOPERATESWUPDATE		3
    {RRUOPERATESWUPDATE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruOperateTable, 3, {10, 1, 3}},
#define RRUOPERATEROWSTATUS		4
    {RRUOPERATEROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruOperateTable, 3, {10, 1, 4}},
};

/*
 * (L = length of the oidsuffix) 
 */


/** Initializes the rruConfigInfo module */
void
init_rruConfigInfo(void)
{

    DEBUGMSGTL(("rruConfigInfo", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("rruConfigInfo", rruConfigInfo_variables, variable4,
                 rruConfigInfo_variables_oid);

    /*
     * place any other initialization junk you need here 
     */
}

/*
 * var_rruConfigInfo():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_rruConfigInfo(struct variable *vp,
                  oid * name,
                  size_t *length,
                  int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        ERROR_MSG("");
    }
    return NULL;
}



UINT32 header_rruReadOnlyTable
(
  struct variable *vp,
  oid			  *name,
  size_t		  *length,
  int			   exact,
  size_t		  *var_len,
  WriteMethod	 **write_method,
  long			  *plIndex
)
{
  UINT32 ret = 0;
  UINT32 lComp =  MATCH_FAILED; 
  UINT32 lIndex = 0;
  oid newname[MAX_OID_LEN];

  memset(newname, 0x00, sizeof(newname));
  memcpy(newname, name, (*length) * sizeof(oid));

  if(exact)  /* get/set  */
  {
	  ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
	  if((ret == 0) && (*length == (vp->namelen + 1)))
	  {
		  lIndex = newname[vp->namelen];
		  if((lIndex > 0) && (lIndex <= MAX_RRU_ID)) 
			  lComp = MATCH_SUCCEEDED;
	  }
  }
  else
  {
	  ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
	  if(ret < 0)
	  {
		  memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));
		  
		  if(get_first_rru_id((UINT16*)&lIndex) == 0)
		  { 			  
			  lComp = MATCH_SUCCEEDED;
		  }
		  #if 0
		  else
		  {
			  if(rruInitMsgTable_RowBuf.rruInitMsgRowStatus != SNMP_ROW_NONEXISTENT)
			  {
				  lComp  = MATCH_SUCCEEDED;
				  lIndex = rruInitMsgTable_RowBuf.rruInitMsgIndex;
			  }
		  }
		  #endif
	  }
	  else if(ret == 0)
	  {
		  if(*length == vp->namelen)
		  {
			  if(get_first_rru_id((UINT16*)&lIndex) == 0)
			  {
				  lComp = MATCH_SUCCEEDED;
			  }
			  #if 0
			  else
			  {
				  if(rruInitMsgTable_RowBuf.rruInitMsgRowStatus != SNMP_ROW_NONEXISTENT)
				  {
					  lComp  = MATCH_SUCCEEDED;
					  lIndex = rruInitMsgTable_RowBuf.rruInitMsgIndex;
				  }
			  }
			  #endif
		  }
		  else if (*length == (vp->namelen + 1))
		  {
			  lIndex = newname[vp->namelen];
			  if(get_next_rru_id((UINT16*)&lIndex) == 0)
			  {
				  lComp  = MATCH_SUCCEEDED;
			  }
			  #if 0
			  else
			  {
				  if(rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NONEXISTENT)
				  {
					  lComp  = MATCH_SUCCEEDED;
					  lIndex = rruInitMsgTable_RowBuf.rruInitMsgIndex;
				  }
			  }
			  #endif			  
		  }
	  }
  }
  
  if(lComp == MATCH_SUCCEEDED)
  {
	 *length  = vp->namelen + 1;
	 *plIndex = lIndex;
	  newname[vp->namelen] = lIndex;
	  memcpy(name, newname, (*length) * sizeof(oid));
  }

  return(lComp);
}

unsigned char  *
var_rruLogicMsgTable(struct variable *vp,
                     oid * name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */

    static unsigned char string[SPRINT_MAX_LEN];

	static long 	VAR = 0;
	long 			lIndex = 0;

	UINT32 			ret = 0;
	UINT32 			haveok = 0;
//    if (header_simple_table
//        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//        == MATCH_FAILED)
//        return NULL;

	ret = header_rruReadOnlyTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
    {
		log_msg(LOG_ERR,CFIG_MGMT,"rru id match failed\n");
        return (u_char *) NULL;
    }

	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}
#if 0
	if(exact)
    {
    	if(vp->magic == RRUINITMSGROWSTATUS || ((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NONEXISTEN) && (lIndex == rruInitMsgTable_RowBuf.rruInitMsgIndex)))
    	{
    		flag = 1;
    	}
		else
		{
			return ((u_char *)NULL);
		}
    }
	else
	{
		flag = 1;
	}
#endif

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RRULOGICMSGINDEX:
		VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULOGICMSGRRUID:
		//*write_method = write_rruLogicMsgRruId;
		VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULOGICMSGNEID:
        //*write_method = write_rruLogicMsgNeId;
		if(get_rru_logic_info((UINT16)lIndex, 0, &VAR, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru logic info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULOGICMSGBBUID:
        //*write_method = write_rruLogicMsgBbuId;
        if(get_rru_logic_info((UINT16)lIndex, 1, &VAR, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru logic info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULOGICMSGFPGAID:
        //*write_method = write_rruLogicMsgFpgaId;
        if(get_rru_logic_info((UINT16)lIndex, 2, &VAR, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru logic info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULOGICMSGCPRIPORT:
        //*write_method = write_rruLogicMsgCpriPort;
		if(get_rru_logic_info((UINT16)lIndex, 3, &VAR, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru logic info failed\n");
		    return (u_char *)NULL;
		}
        //*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULOGICMSGBBUIP:
        //*write_method = write_rruLogicMsgBbuIp;
		memset(string, 0, sizeof(string));
        if(get_rru_logic_info((UINT16)lIndex, 4, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru logic info failed\n");
		    return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRULOGICMSGRRUIP:
        //*write_method = write_rruLogicMsgRruIp;
		memset(string, 0, sizeof(string));
        if(get_rru_logic_info((UINT16)lIndex, 5, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru logic info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRULOGICMSGRRUMAC:
        //*write_method = write_rruLogicMsgRruMac;
        memset(string, 0, sizeof(string));
        if(get_rru_logic_info((UINT16)lIndex, 6, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru logic info failed\n");
		    return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRULOGICMSGSUBMASK:
        //*write_method = write_rruLogicMsgSubMask;
        memset(string, 0, sizeof(string));
        if(get_rru_logic_info((UINT16)lIndex, 7, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru logic info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRULOGICMSGROWSTATUS:
        *write_method = write_rruLogicMsgRowStatus;
        return NULL;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_rruProductMsgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_rruConfigInfo above.
 */
unsigned char  *
var_rruProductMsgTable(struct variable *vp,
                       oid * name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static unsigned char string[SPRINT_MAX_LEN];

	static long 	VAR = 0;
	long 			lIndex = 0;

	UINT32 			ret = 0;
	UINT32 			haveok = 0;

//    if (header_simple_table
//        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//        == MATCH_FAILED)
//        return NULL;
	ret = header_rruReadOnlyTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
	{
		log_msg(LOG_ERR,CFIG_MGMT,"rru id match failed\n");
		return (u_char *)NULL;
	}

	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}

    switch (vp->magic) {
    case RRUPRODUCTMSGINDEX:
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUPRODUCTMSGRRUID:
        //*write_method = write_rruProductMsgRruId;
		VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUPRODUCTMSGMANUFACTUERE:
        //*write_method = write_rruProductMsgManufactuere;
		memset(string, 0, sizeof(string));
        if(get_rru_product_info((UINT16)lIndex, 1, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru product info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRUPRODUCTMSGPUBLISHER:
        //*write_method = write_rruProductMsgPublisher;
        memset(string, 0, sizeof(string));
        if(get_rru_product_info((UINT16)lIndex, 2, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru product info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRUPRODUCTMSGSERIALNO:
        //*write_method = write_rruProductMsgSerialNo;
        memset(string, 0, sizeof(string));
        if(get_rru_product_info((UINT16)lIndex, 3, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru product info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRUPRODUCTMSGMANUFACTUREDATE:
        //*write_method = write_rruProductMsgManufactureDate;
        memset(string, 0, sizeof(string));
        if(get_rru_product_info((UINT16)lIndex, 4, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru product info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRUPRODUCTMSGLASTSERVICEDATE:
        //*write_method = write_rruProductMsgLastServiceDate;
        memset(string, 0, sizeof(string));
        if(get_rru_product_info((UINT16)lIndex, 5, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru product info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRUPRODUCTMSGEXTRAINFO:
        //*write_method = write_rruProductMsgExtraInfo;
        memset(string, 0, sizeof(string));
        if(get_rru_product_info((UINT16)lIndex, 6, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru product info failed\n");
			return (u_char *)NULL;
		}
        //*var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRUPRODUCTMSGROWSTATUS:
        *write_method = write_rruProductMsgRowStatus;
        return NULL;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


UINT32 header_rruCfgMsgTable
(
   struct variable *vp,
   oid			   *name,
   size_t		   *length,
   int				exact,
   size_t		   *var_len,
   WriteMethod	  **write_method,
   long 		   *plIndex
)
{
   UINT32 ret = 0;
   UINT32 lComp =  MATCH_FAILED; 
   UINT32 lIndex = 0;
   oid newname[MAX_OID_LEN];

   memset(newname, 0x00, sizeof(newname));
   memcpy(newname, name, (*length) * sizeof(oid));

   if(exact)  /* get/set  */
   {
	   ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
	   if((ret == 0) && (*length == (vp->namelen + 1)))
	   {
		   lIndex = newname[vp->namelen];
		   if((lIndex > 0) && (lIndex <= MAX_RRU_ID)) 
			   lComp = MATCH_SUCCEEDED;
	   }
   }
   else
   {
	   ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
	   if(ret < 0)
	   {
		   memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));
		   
		   if(get_first_rru_id((UINT16*)&lIndex) == 0)
		   {			   
			   lComp = MATCH_SUCCEEDED;
		   }
		   else
		   {
			   if(rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus != SNMP_ROW_NONEXISTENT)
			   {
				   lComp  = MATCH_SUCCEEDED;
				   lIndex = rruCfgMsgTable_RowBuf.rruCfgMsgIndex;
			   }
		   }
	   }
	   else if(ret == 0)
	   {
		   if(*length == vp->namelen)
		   {
			   if(get_first_rru_id((UINT16*)&lIndex) == 0)
			   {
				   lComp = MATCH_SUCCEEDED;
			   }
			   else
			   {
				   if(rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus != SNMP_ROW_NONEXISTENT)
				   {
					   lComp  = MATCH_SUCCEEDED;
					   lIndex = rruCfgMsgTable_RowBuf.rruCfgMsgIndex;
				   }
			   }
		   }
		   else if (*length == (vp->namelen + 1))
		   {
			   lIndex = newname[vp->namelen];
			   if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NONEXISTENT) || 
				  (rruCfgMsgTable_RowBuf.rruCfgMsgIndex != lIndex))
			   {
				   if(get_next_rru_id((UINT16*)&lIndex) == 0)
				   {
					   lComp  = MATCH_SUCCEEDED;
				   }else{
					   if(rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NONEXISTENT)
					   {
						   lComp  = MATCH_SUCCEEDED;
						   lIndex = rruCfgMsgTable_RowBuf.rruCfgMsgIndex;
					   }
				   }
			   }
		   }
	   }
   }
   
   if(lComp == MATCH_SUCCEEDED)
   {
	  *length  = vp->namelen + 1;
	  *plIndex = lIndex;
	   newname[vp->namelen] = lIndex;
	   memcpy(name, newname, (*length) * sizeof(oid));
   }

   return(lComp);
}

unsigned char  *
var_rruCfgMsgTable(struct variable *vp,
                   oid * name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */

    static unsigned char string[SPRINT_MAX_LEN];

	
	static long 	VAR = 0;
	long			lIndex = 0;

	UINT32			ret = 0;
	UINT32			haveok = 0;
	UINT32			up_pathstate[8] = {0};
    UINT32			dw_pathstate[8] = {0};
	
//    if (header_simple_table
//        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//        == MATCH_FAILED)
//        return NULL;
	ret = header_rruCfgMsgTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
    {
		log_msg(LOG_ERR,CFIG_MGMT,"rru id match failed\n");
		return (u_char *)NULL;
    }
	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}
    
    switch (vp->magic) {
    case RRUCFGMSGINDEX:
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGRRUID:
        *write_method = write_rruCfgMsgRruId;
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGCPUUSAGE:
        //*write_method = write_rruCfgMsgCpuUsage;
        if(get_rru_param_cpu_usage((UINT16)lIndex, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru cpu_usage info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGPERIOD:
        *write_method = write_rruCfgMsgPeriod;
		if(get_rru_param_cpu_usage_period((UINT16)lIndex, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru cpu usage period info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGTEMPVAL:
        //*write_method = write_rruCfgMsgTempVal;
		memset(string, 0, sizeof(string));
		if(get_rru_param_temp_val((UINT16)lIndex, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get rru_param_temp_val info failed\n");
			return (u_char *)NULL;
		}
        ;
        return (u_char *) string;
    case RRUCFGMSGVSWRVAL:
        //*write_method = write_rruCfgMsgVswrVal;
		memset(string, 0, sizeof(string));
		if(get_rru_param_vswr_val((UINT16)lIndex, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_param_vswr_val info failed\n");
			return (u_char *)NULL;
		}
        
        return (u_char *) string;
    case RRUCFGMSGVSWRTHRES1:
        *write_method = write_rruCfgMsgVswrThres1;
		if(get_rru_param_vswr_thres((UINT16)lIndex, 0, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_param_vswr_thres info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGVSWRTHRES2:
        *write_method = write_rruCfgMsgVswrThres2;
		if(get_rru_param_vswr_thres((UINT16)lIndex, 1, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_param_vswr_thres failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGPPOWERVAL:
        //*write_method = write_rruCfgMsgpPowerVal;
        memset(string, 0, sizeof(string));
        if(get_rru_param_power_val((UINT16)lIndex, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_param_power_val failed\n");
			return (u_char *)NULL;
		}
        return (u_char *) string;
    case RRUCFGMSGUPTHRES:
        *write_method = write_rruCfgMsgUpThres;
		VAR = rruCfgMsgTable_RowBuf.rruCfgMsgUpThres;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGLOWTHRES:
        *write_method = write_rruCfgMsgLowThres;
        VAR = rruCfgMsgTable_RowBuf.rruCfgMsgLowThres;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGANTMODE:
        *write_method = write_rruCfgMsgAntMode;
        VAR = rruCfgMsgTable_RowBuf.rruCfgMsgAntMode;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGANTSETNO:
        *write_method = write_rruCfgMsgAntSetNo;
        VAR = rruCfgMsgTable_RowBuf.rruCfgMsgAntSetNo;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGANTSTATE:
        *write_method = write_rruCfgMsgAntState;
         VAR = rruCfgMsgTable_RowBuf.rruCfgMsgAntState;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGUPPATHSTATE:
        *write_method = write_rruCfgMsgUpPathState;
		 memset(string, 0, sizeof(string));
        if(get_rru_channel_state((UINT16)lIndex,0, up_pathstate, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_channel_state info failed\n");
			return (u_char *)NULL;
		}
		intVec2charVec(string, up_pathstate, 8);
        *var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRUCFGMSGDWPATHSTATE:
        *write_method = write_rruCfgMsgDwPathState;
		memset(string, 0, sizeof(string));
        if(get_rru_channel_state((UINT16)lIndex,1 , dw_pathstate, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_channel_state info failed\n");
			return (u_char *)NULL;
		}
		intVec2charVec(string, dw_pathstate, 8);
        *var_len = strlen(string) + 1;
        return (u_char *) string;
    case RRUCFGMSGSTATE:
        //*write_method = write_rruCfgMsgState;
		VAR = 0;
        if(get_rru_param_state((UINT16)lIndex, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_param_state info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGCLOCKSTATE:
        //*write_method = write_rruCfgMsgClockState;
		VAR = 0;
		if(get_rru_clock_state((UINT16)lIndex, &VAR) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_clock_state failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUCFGMSGROWSTATUS:
        *write_method = write_rruCfgMsgRowStatus;
         VAR = rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_rruLatestChannelSetTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_rruConfigInfo above.
 */
unsigned char  *
var_rruLatestChannelSetTable(struct variable *vp,
                             oid * name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
	
	static long 	VAR = 0;
	long 			lIndex = 0;

	UINT32 			ret = 0;
	UINT32 			haveok = 0;

//    if (header_simple_table
//        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//        == MATCH_FAILED)
//        return NULL;
	
	ret = header_rruReadOnlyTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
    {
		log_msg(LOG_ERR,CFIG_MGMT,"rru id match failed\n");
		return (u_char *)NULL;
    }

	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}

    switch (vp->magic) {
    case RRULATESTCHANNELSETINDEX:
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULATESTCHANNELSETRRUID:
        //*write_method = write_rruLatestChannelSetRruId;
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULATESTCHANNELSETREASON:
       // *write_method = write_rruLatestChannelSetReason;
        VAR = 0;
        if(get_rru_channel_build_reason((UINT16)lIndex, 0, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_channel_build_reason failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULATESTCHANNELSETALARMCODE:
        //*write_method = write_rruLatestChannelSetAlarmCode;
        VAR = 0;
        if(get_rru_channel_build_reason((UINT16)lIndex, 1, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_channel_build_reason failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRULATESTCHANNELSETROWSTATUS:
        //*write_method = write_rruLatestChannelSetRowStatus;
        
        return (u_char *) NULL;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_rruAbilityMsgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_rruConfigInfo above.
 */
unsigned char  *
var_rruAbilityMsgTable(struct variable *vp,
                       oid * name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
	static long 	VAR = 0;
	long			lIndex = 0;
	long			flag = 0;
	UINT32			ret = 0;
	UINT32			haveok = 0;

//	if (header_simple_table
//		(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//		== MATCH_FAILED)
//		return NULL;
	
	ret = header_rruReadOnlyTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
	{
		log_msg(LOG_ERR,CFIG_MGMT,"rru id match failed\n");
		return (u_char *)NULL;
	}

	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}

    switch (vp->magic) {
    case RRUABILITYMSGINDEX:
         VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGRRUID:
        //*write_method = write_rruAbilityMsgRruId;
         VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGTDCARRIERNUM:
        //*write_method = write_rruAbilityMsgTdCarrierNum;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 0, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGLTECARRIERNUM:
        //*write_method = write_rruAbilityMsgLteCarrierNum;
		VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 1, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGANTNUM:
        //*write_method = write_rruAbilityMsgAntNum;
		VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 2, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGMAXPOWER:
        //*write_method = write_rruAbilityMsgMaxPower;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 3, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGMASTERORSLAVE:
        //*write_method = write_rruAbilityMsgMasterOrSlave;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 4, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGMAXDWTIMEDELAY:
        //*write_method = write_rruAbilityMsgMaxDwTimeDelay;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 5, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGMAXUPTIMEDELAY:
        //*write_method = write_rruAbilityMsgMaxUpTimeDelay;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 6, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGSUPPORTMODE:
        //*write_method = write_rruAbilityMsgSupportMode;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 7, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGANTCLBRTFLAG:
        //*write_method = write_rruAbilityMsgAntClbrtFlag;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 8, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGMAINSENDEMEPATH:
        //*write_method = write_rruAbilityMsgMainSendEmePath;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 9, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGSLAVESENDEMEPATH:
        //*write_method = write_rruAbilityMsgSlaveSendEmePath;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 10, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGMAINRECVEMEPATH:
        //*write_method = write_rruAbilityMsgMainRecvEmePath;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 11, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGSLAVERECVEMEPATH:
        //*write_method = write_rruAbilityMsgSlaveRecvEmePath;
        VAR = 0;
        if(get_rru_ability_info((UINT16)lIndex, 12, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ability_info failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUABILITYMSGROWSTATUS:
        *write_method = write_rruAbilityMsgRowStatus;
     
        return (u_char *) NULL;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_rruSoftHardMsgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_rruConfigInfo above.
 */
unsigned char  *
var_rruSoftHardMsgTable(struct variable *vp,
                        oid * name,
                        size_t *length,
                        int exact,
                        size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */

    static unsigned char string[SPRINT_MAX_LEN];


	static long 	VAR = 0;
	long			lIndex = 0;

	UINT32			ret = 0;
	UINT32			haveok = 0;

//	if (header_simple_table
//		(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//		== MATCH_FAILED)
//		return NULL;
	
	ret = header_rruReadOnlyTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
	{
		log_msg(LOG_ERR,CFIG_MGMT,"rru id match failed\n");
		return (u_char *)NULL;
	}

	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}

    switch (vp->magic) {
    case RRUSOFTHARDMSGINDEX:
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUSOFTHARDMSGRRUID:
        //*write_method = write_rruSoftHardMsgRruId;
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUSOFTHARDMSGHWTYPE:
        //*write_method = write_rruSoftHardMsgHwType;
        memset(string, 0, sizeof(string));
        if(get_rru_ware_info((UINT16)lIndex, 0, string, var_len) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ware_info failed\n");
			return (u_char *)NULL;
		}
        return (u_char *) string;
    case RRUSOFTHARDMSGHWVERSION:
        //*write_method = write_rruSoftHardMsgHwVersion;
        memset(string, 0, sizeof(string));
        if(get_rru_ware_info((UINT16)lIndex, 1, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ware_info failed\n");
			return (u_char *)NULL;
		}
        return (u_char *) string;
    case RRUSOFTHARDMSGSWVER:
        //*write_method = write_rruSoftHardMsgSwVer;
        memset(string, 0, sizeof(string));
        if(get_rru_ware_info((UINT16)lIndex, 2, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ware_info failed\n");
			return (u_char *)NULL;
		}
        return (u_char *) string;
    case RRUSOFTHARDMSGFWVER:
        //*write_method = write_rruSoftHardMsgFwVer;
        memset(string, 0, sizeof(string));
        if(get_rru_ware_info((UINT16)lIndex, 3, string, (UINT32*)var_len) != 0){
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_ware_info failed\n");
			return (u_char *)NULL;
		}
        return (u_char *) string;
    case RRUSOFTHARDMSGROWSTATUS:
        *write_method = write_rruSoftHardMsgRowStatus;
        return (u_char *) NULL;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_rruDelayMeasureTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_rruConfigInfo above.
 */
unsigned char  *
var_rruDelayMeasureTable(struct variable *vp,
                         oid * name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */



	
	static long 	VAR = 0;
	long			lIndex = 0;

	UINT32			ret = 0;
	UINT32			haveok = 0;

//	if (header_simple_table
//		(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//		== MATCH_FAILED)
//		return NULL;
	
	ret = header_rruReadOnlyTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
	{
		log_msg(LOG_ERR,CFIG_MGMT,"rru id match failed\n");
		return (u_char *)NULL;
	}

	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}

    switch (vp->magic) {
    case RRUDELAYMEASUREINDEX:
         VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDELAYMEASURERRUID:
        //*write_method = write_rruDelayMeasureRruId;
         VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDELAYMEASUREFIBERNO:
        //*write_method = write_rruDelayMeasureFiberNo;
        VAR = 0;
        if(get_rru_time_delay_measure((UINT16)lIndex, 0, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_measure failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDELAYMEASURETOFFSET:
        //*write_method = write_rruDelayMeasureTOffset;
        VAR = 0;
        if(get_rru_time_delay_measure((UINT16)lIndex, 1, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_measure failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDELAYMEASURETBDELAYDL:
        //*write_method = write_rruDelayMeasureTbDelayDl;
       VAR = 0;
        if(get_rru_time_delay_measure((UINT16)lIndex, 2, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_measure failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDELAYMEASURETBDELAYUL:
        //*write_method = write_rruDelayMeasureTbDelayUl;
        VAR = 0;
        if(get_rru_time_delay_measure((UINT16)lIndex, 3, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_measure failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDELAYMEASURET2A:
        //*write_method = write_rruDelayMeasureT2a;
        VAR = 0;
        if(get_rru_time_delay_measure((UINT16)lIndex, 4, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_measure failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDELAYMEASURET3A:
        //*write_method = write_rruDelayMeasureT3a;
        VAR = 0;
        if(get_rru_time_delay_measure((UINT16)lIndex, 5, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_measure failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDELAYMEASUREROWSTATUS:
        *write_method = write_rruDelayMeasureRowStatus;
        return (u_char *) NULL;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


 UINT32 header_rruDealyCfgTable
 (
	struct variable *vp,
	oid 			*name,
	size_t			*length,
	int 			 exact,
	size_t			*var_len,
	WriteMethod    **write_method,
	long			*plIndex
 )
 {
	UINT32 ret = 0;
	UINT32 lComp =	MATCH_FAILED; 
	UINT32 lIndex = 0;
	oid newname[MAX_OID_LEN];
 
	memset(newname, 0x00, sizeof(newname));
	memcpy(newname, name, (*length) * sizeof(oid));
 
	if(exact)  /* get/set  */
	{
		ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
		if((ret == 0) && (*length == (vp->namelen + 1)))
		{
			lIndex = newname[vp->namelen];
			if((lIndex > 0) && (lIndex <= MAX_RRU_ID)) 
				lComp = MATCH_SUCCEEDED;
		}
	}
	else
	{
		ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
		if(ret < 0)
		{
			memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));
			
			if(get_first_rru_id(&lIndex) == 0)
			{				
				lComp = MATCH_SUCCEEDED;
			}
			else
			{
				if(rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus != SNMP_ROW_NONEXISTENT)
				{
					lComp  = MATCH_SUCCEEDED;
					lIndex = rruDealyCfgTable_RowBuf.rruDealyCfgIndex;
				}
			}
		}
		else if(ret == 0)
		{
			if(*length == vp->namelen)
			{
				if(get_first_rru_id((UINT32*)(&lIndex)) == 0)
				{
					lComp = MATCH_SUCCEEDED;
				}
				else
				{
					if(rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus != SNMP_ROW_NONEXISTENT)
					{
						lComp  = MATCH_SUCCEEDED;
						lIndex = rruDealyCfgTable_RowBuf.rruDealyCfgIndex;
					}
				}
			}
			else if (*length == (vp->namelen + 1))
			{
				lIndex = newname[vp->namelen];
				if((rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus == SNMP_ROW_NONEXISTENT) ||
				   ((rruDealyCfgTable_RowBuf.rruDealyCfgIndex != lIndex)))
				{
					if(get_next_rru_id(&lIndex) == 0)
					{
						lComp  = MATCH_SUCCEEDED;
					}
					else
					{
						if(rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus == SNMP_ROW_NONEXISTENT)
						{
							lComp  = MATCH_SUCCEEDED;
							lIndex = rruDealyCfgTable_RowBuf.rruDealyCfgIndex;
						}
					}
				}
			}
		}
	}
	
	if(lComp == MATCH_SUCCEEDED)
	{
	   *length	= vp->namelen + 1;
	   *plIndex = lIndex;
		newname[vp->namelen] = lIndex;
		memcpy(name, newname, (*length) * sizeof(oid));
	}
 
	return(lComp);
 }
						 
unsigned char  *
var_rruDealyCfgTable(struct variable *vp,
                     oid * name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */

	static long 	VAR = 0;
	long			lIndex = 0;

	UINT32			ret = 0;
	UINT32			haveok = 0;
	
//    if (header_simple_table
//        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//        == MATCH_FAILED)
//        return NULL;
	ret = header_rruDealyCfgTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
	{
		log_msg(LOG_ERR,CFIG_MGMT,"rru id match failed\n");
		return (u_char *)NULL;
	}
	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}

    switch (vp->magic) {
    case RRUDEALYCFGINDEX:
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDEALYCFGRRUID:
        *write_method = write_rruDealyCfgRruId;
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDEALYCFGFIBERNO:
        *write_method = write_rruDealyCfgFiberNo;
		if(get_rru_time_delay_cfg((UINT16)lIndex, 0, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_cfg failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDEALYCFGTRXARXM:
        *write_method = write_rruDealyCfgTrxaRxm;
		if(get_rru_time_delay_cfg((UINT16)lIndex, 1, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_cfg failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDEALYCFGTRXMRXA:
        *write_method = write_rruDealyCfgTrxmRxa;
        if(get_rru_time_delay_cfg((UINT16)lIndex, 2, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_cfg failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDEALYCFGTIMEADV:
        *write_method = write_rruDealyCfgTimeAdv;
        if(get_rru_time_delay_cfg((UINT16)lIndex, 3, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_cfg failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDEALYCFGDLCALRRU:
        *write_method = write_rruDealyCfgDlCalRru;
        if(get_rru_time_delay_cfg((UINT16)lIndex, 4, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_cfg failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDEALYCFGULCALRRU:
        *write_method = write_rruDealyCfgUlCalRru;
        if(get_rru_time_delay_cfg((UINT16)lIndex, 5, &VAR) != 0){  
			*var_len = 0;
			log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_cfg failed\n");
			return (u_char *)NULL;
		}
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUDEALYCFGROWSTATUS:
        *write_method = write_rruDealyCfgRowStatus;
        VAR = rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


  UINT32 header_rruRingTestTable
  (
	 struct variable *vp,
	 oid			 *name,
	 size_t 		 *length,
	 int			  exact,
	 size_t 		 *var_len,
	 WriteMethod	**write_method,
	 long			 *plIndex
  )
  {
	 UINT32 ret = 0;
	 UINT32 lComp =  MATCH_FAILED; 
	 UINT32 lIndex = 0;
	 oid newname[MAX_OID_LEN];
  
	 memset(newname, 0x00, sizeof(newname));
	 memcpy(newname, name, (*length) * sizeof(oid));
  
	 if(exact)	/* get/set	*/
	 {
		 ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
		 if((ret == 0) && (*length == (vp->namelen + 1)))
		 {
			 lIndex = newname[vp->namelen];
			 if((lIndex > 0) && (lIndex <= MAX_RRU_ID)) 
				 lComp = MATCH_SUCCEEDED;
		 }
	 }
	 else
	 {
		 ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
		 if(ret < 0)
		 {
			 memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));
			 
			 if(get_first_rru_id(&lIndex) == 0)
			 {				 
				 lComp = MATCH_SUCCEEDED;
			 }
			 else
			 {
				 if(rruRingTestTable_RowBuf.rruRingTestRowStatus != SNMP_ROW_NONEXISTENT)
				 {
					 lComp	= MATCH_SUCCEEDED;
					 lIndex = rruRingTestTable_RowBuf.rruRingTestIndex;
				 }
			 }
		 }
		 else if(ret == 0)
		 {
			 if(*length == vp->namelen)
			 {
				 if(get_first_rru_id((UINT16*)&lIndex) == 0)
				 {
					 lComp = MATCH_SUCCEEDED;
				 }
				 else
				 {
					 if(rruRingTestTable_RowBuf.rruRingTestRowStatus != SNMP_ROW_NONEXISTENT)
					 {
						 lComp	= MATCH_SUCCEEDED;
						 lIndex = rruRingTestTable_RowBuf.rruRingTestIndex;
					 }
				 }
			 }
			 else if (*length == (vp->namelen + 1))
			 {
				 lIndex = newname[vp->namelen];
				 if((rruRingTestTable_RowBuf.rruRingTestRowStatus == SNMP_ROW_NONEXISTENT) ||
					(rruRingTestTable_RowBuf.rruRingTestIndex != lIndex))
				 {
					 if(get_next_rru_id((UINT16*)&lIndex) == 0)
					 {
						 lComp	= MATCH_SUCCEEDED;
					 }
					 else
					 {
						 if(rruRingTestTable_RowBuf.rruRingTestRowStatus == SNMP_ROW_NONEXISTENT)
						 {
							 lComp	= MATCH_SUCCEEDED;
							 lIndex = rruRingTestTable_RowBuf.rruRingTestIndex;
						 }
					 }
				 }
			 }
		 }
	 }
	 
	 if(lComp == MATCH_SUCCEEDED)
	 {
		*length  = vp->namelen + 1;
		*plIndex = lIndex;
		 newname[vp->namelen] = lIndex;
		 memcpy(name, newname, (*length) * sizeof(oid));
	 }
  
	 return(lComp);
  }


unsigned char  *
var_rruRingTestTable(struct variable *vp,
                     oid * name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */

	static long 	VAR = 0;
	long			lIndex = 0;

	UINT32			ret = 0;
	UINT32			haveok = 0;
	
//    if (header_simple_table
//        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//        == MATCH_FAILED)
//        return NULL;
	
	ret = header_rruDealyCfgTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
	{
		log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_cfg failed\n");
		return (u_char *)NULL;
	}
	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}

    switch (vp->magic) {
    case RRURINGTESTINDEX:
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRURINGTESTRRUID:
        *write_method = write_rruRingTestRruId;
        VAR = rruRingTestTable_RowBuf.rruRingTestRruId;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRURINGTESTTYPE:
        *write_method = write_rruRingTestType;
         VAR = rruRingTestTable_RowBuf.rruRingTestType;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRURINGTESTCHECKPERIOD:
        *write_method = write_rruRingTestCheckPeriod;
       VAR = rruRingTestTable_RowBuf.rruRingTestCheckPeriod;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRURINGTESTPORTNO:
        *write_method = write_rruRingTestPortNo;
        VAR = rruRingTestTable_RowBuf.rruRingTestPortNo;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRURINGTESTROWSTATUS:
        *write_method = write_rruRingTestRowStatus;
        VAR = rruRingTestTable_RowBuf.rruRingTestRowStatus;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

UINT32 header_rruOperateTable
(
  struct variable *vp,
  oid			  *name,
  size_t		  *length,
  int			   exact,
  size_t		  *var_len,
  WriteMethod	 **write_method,
  long			  *plIndex
)
{
  UINT32 ret = 0;
  UINT32 lComp =  MATCH_FAILED; 
  UINT32 lIndex = 0;
  oid newname[MAX_OID_LEN];

  memset(newname, 0x00, sizeof(newname));
  memcpy(newname, name, (*length) * sizeof(oid));

  if(exact)  /* get/set  */
  {
	  ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
	  if((ret == 0) && (*length == (vp->namelen + 1)))
	  {
		  lIndex = newname[vp->namelen];
		  if((lIndex > 0) && (lIndex <= MAX_RRU_ID)) 
			  lComp = MATCH_SUCCEEDED;
	  }
  }
  else
  {
	  ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
	  if(ret < 0)
	  {
		  memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));
		  
		  if(get_first_rru_id((UINT16*)&lIndex) == 0)
		  { 			  
			  lComp = MATCH_SUCCEEDED;
		  }
		  else
		  {
			  if(rruOperateTable_RowBuf.rruOperateRowStatus != SNMP_ROW_NONEXISTENT)
			  {
				  lComp  = MATCH_SUCCEEDED;
				  lIndex = rruOperateTable_RowBuf.rruOperateIndex;
			  }
		  }
	  }
	  else if(ret == 0)
	  {
		  if(*length == vp->namelen)
		  {
			  if(get_first_rru_id((UINT16*)&lIndex) == 0)
			  {
				  lComp = MATCH_SUCCEEDED;
			  }
			  else
			  {
				  if(rruOperateTable_RowBuf.rruOperateRowStatus != SNMP_ROW_NONEXISTENT)
				  {
					  lComp  = MATCH_SUCCEEDED;
					  lIndex = rruOperateTable_RowBuf.rruOperateIndex;
				  }
			  }
		  }
		  else if (*length == (vp->namelen + 1))
		  {
			  lIndex = newname[vp->namelen];
			  if((rruOperateTable_RowBuf.rruOperateRowStatus == SNMP_ROW_NONEXISTENT) ||
				 (rruOperateTable_RowBuf.rruOperateIndex != lIndex))
			  {
				  if(get_next_rru_id((UINT16*)&lIndex) == 0)
				  {
					  lComp  = MATCH_SUCCEEDED;
				  }
				  else
				  {
					  if(rruOperateTable_RowBuf.rruOperateRowStatus == SNMP_ROW_NONEXISTENT)
					  {
						  lComp  = MATCH_SUCCEEDED;
						  lIndex = rruOperateTable_RowBuf.rruOperateIndex;
					  }
				  }
			  }
		  }
	  }
  }
  
  if(lComp == MATCH_SUCCEEDED)
  {
	 *length  = vp->namelen + 1;
	 *plIndex = lIndex;
	  newname[vp->namelen] = lIndex;
	  memcpy(name, newname, (*length) * sizeof(oid));
  }

  return(lComp);
}

/*
 * var_rruOperateTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_rruConfigInfo above.
 */
unsigned char  *
var_rruOperateTable(struct variable *vp,
                    oid * name,
                    size_t *length,
                    int exact,
                    size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */

	static long 	VAR = 0;
	long			lIndex = 0;

	UINT32			ret = 0;
	UINT32			haveok = 0;
	
//	if (header_simple_table
//		(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//		== MATCH_FAILED)
//		return NULL;
	
	ret = header_rruOperateTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
	{
		log_msg(LOG_ERR,CFIG_MGMT,"get_rru_time_delay_cfg failed\n");
	    return (u_char *)NULL;
	}
	haveok = check_exist_rru_id((UINT16)lIndex);
	if(haveok == -1){
		return NULL;
	}
   
    switch (vp->magic) {
    case RRUOPERATEINDEX:
        *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUOPERATERESETTYPE:
        *write_method = write_rruOperateResetType;
        VAR = rruOperateTable_RowBuf.rruOperateResetType;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUOPERATESWUPDATE:
        *write_method = write_rruOperateSwUpdate;
        VAR = rruOperateTable_RowBuf.rruOperateSwUpdate;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUOPERATEROWSTATUS:
        *write_method = write_rruOperateRowStatus;
       VAR = rruOperateTable_RowBuf.rruOperateRowStatus;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int
write_rruLogicMsgRowStatus(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruProductMsgRowStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgRruId(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_rruCfgMsgPeriod(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

	long						lVar = 0;
	long						lIndex = 0;
	ICR_RRU_PARAM_CPU_USAGE_PERIOD 			rru_param_cpu_usage_period_msg;
	INT32 									rru_param_cpu_usage_period_msg_len;
	rru_param_cpu_usage_period_msg_len = sizeof(ICR_RRU_PARAM_CPU_USAGE_PERIOD);
	memset(&rru_param_cpu_usage_period_msg, 0, sizeof(rru_param_cpu_usage_period_msg));

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		rru_param_cpu_usage_period_msg.head.msg_type = MODULE_CFIG_MGMT;
		rru_param_cpu_usage_period_msg.head.msg_code = SET_RRU_PARAM_CPU_USAGE_PERIOD;
		rru_param_cpu_usage_period_msg.head.msg_len = rru_param_cpu_usage_period_msg_len;
		rru_param_cpu_usage_period_msg.rru_id = lIndex;
		if(send_msg_to_om(MODULE_RRUS_MGMT, (char*)&rru_param_cpu_usage_period_msg, rru_param_cpu_usage_period_msg_len) != 0)
		{
			return (SNMP_ERR_COMMITFAILED);
		}					
#if 0
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
		{
			rruInitMsgTable_RowBuf.rruInitMsgPeriod = value;
			setbit(rruInitMsgTable_RowBuf.FIN_FLAG,2);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
#endif
	   
		break;
       

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_rruCfgMsgVswrThres1(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
        {
        	rruCfgMsgTable_RowBuf.rruCfgMsgVswrThres1 = value;
			setbit(rruCfgMsgTable_RowBuf.fin_flag_vswr_thres,0);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgVswrThres2(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
        {
        	rruCfgMsgTable_RowBuf.rruCfgMsgVswrThres1 = value;
			setbit(rruCfgMsgTable_RowBuf.fin_flag_vswr_thres,1);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgUpThres(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
        {
        	rruCfgMsgTable_RowBuf.rruCfgMsgUpThres = value;
			setbit(rruCfgMsgTable_RowBuf.fin_flag_temp_thres,0);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgLowThres(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
        {
        	rruCfgMsgTable_RowBuf.rruCfgMsgLowThres = value;
			setbit(rruCfgMsgTable_RowBuf.fin_flag_temp_thres,1);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgAntMode(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
        {
        	rruCfgMsgTable_RowBuf.rruCfgMsgAntMode = value;
			setbit(rruCfgMsgTable_RowBuf.fin_flag_ant_cfg,0);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgAntSetNo(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
        {
        	rruCfgMsgTable_RowBuf.rruCfgMsgAntSetNo = value;
			setbit(rruCfgMsgTable_RowBuf.fin_flag_ant_cfg,1);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgAntState(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
        {
        	rruCfgMsgTable_RowBuf.rruCfgMsgAntState = value;
			setbit(rruCfgMsgTable_RowBuf.fin_flag_ant_cfg,2);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgUpPathState(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to rruConfigInfo not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
        {
        	memcpy(&rruCfgMsgTable_RowBuf.rruCfgMsgUpPathState, var_val, size);
			setbit(rruCfgMsgTable_RowBuf.fin_flag_channel_state,0);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgDwPathState(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to rruConfigInfo not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
        {
        	memcpy(&rruCfgMsgTable_RowBuf.rruCfgMsgDwPathState, var_val, size);
			setbit(rruCfgMsgTable_RowBuf.fin_flag_channel_state,1);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruCfgMsgRowStatus(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

	long 				lVar = 0;
	long 				lIndex = 0;
	
	ICR_RRU_PARAM_VSWR_THRES 	rru_param_vswr_thres_msg;
	ICR_RRU_PARAM_TEMP_THRES	rru_param_temp_thres_msg;
	ICR_RRU_PARAM_ANT_CFG		rru_param_ant_cfg_msg;
	ICR_RRU_PARAM_CHANNEL_STATE		rru_param_channel_state_msg;
	
	UINT32 						rru_param_vswr_thres_msg_len;
	UINT32 						rru_param_temp_thres_msg_len;
	UINT32 						rru_param_ant_cfg_msg_len;
	UINT32 						rru_param_channel_state_msg_len;
	
	memset(&rru_param_vswr_thres_msg, 0, sizeof(rru_param_vswr_thres_msg));
	memset(&rru_param_temp_thres_msg, 0, sizeof(rru_param_temp_thres_msg));
	memset(&rru_param_ant_cfg_msg, 0, sizeof(rru_param_ant_cfg_msg));
	memset(&rru_param_channel_state_msg, 0, sizeof(rru_param_channel_state_msg));
	
	rru_param_vswr_thres_msg_len = sizeof(ICR_RRU_PARAM_VSWR_THRES);
	rru_param_temp_thres_msg_len = sizeof(ICR_RRU_PARAM_TEMP_THRES);
	rru_param_ant_cfg_msg_len = sizeof(ICR_RRU_PARAM_ANT_CFG);
	rru_param_channel_state_msg_len = sizeof(ICR_RRU_PARAM_CHANNEL_STATE);
	

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lVar = *(long *)var_val;
        if((lVar < 0) || (lVar > 6)) 
			return(SNMP_ERR_WRONGVALUE);
	    lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		switch(lVar)
		{
			case SNMP_ROW_CREATEANDWAIT:
				memset(&rruCfgMsgTable_RowBuf, 0x00, sizeof(rruCfgMsgTable_RowBuf));
				rruCfgMsgTable_RowBuf.rruCfgMsgIndex = lIndex;
		  		rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus = SNMP_ROW_NOTINSERVICE;
			    break;
				
			case SNMP_ROW_ACTIVE:
				if((rruCfgMsgTable_RowBuf.fin_flag_vswr_thres == 0X03) && (rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE)) /*****vswr �������****/
				{
					rru_param_vswr_thres_msg.head.msg_type = MODULE_CFIG_MGMT;
					rru_param_vswr_thres_msg.head.msg_code = SET_RRU_PARAM_VSWR_THRES;
					rru_param_vswr_thres_msg.head.msg_len = rru_param_vswr_thres_msg_len;
					rru_param_vswr_thres_msg.rru_id = rruCfgMsgTable_RowBuf.rruCfgMsgIndex;
					rru_param_vswr_thres_msg.VswrThres1 = rruCfgMsgTable_RowBuf.rruCfgMsgVswrThres1;
					rru_param_vswr_thres_msg.VswrThres2 = rruCfgMsgTable_RowBuf.rruCfgMsgVswrThres2;
					
					if(send_msg_to_om(MODULE_RRUS_MGMT, (char*)&rru_param_vswr_thres_msg, rru_param_vswr_thres_msg_len) != 0)
					{
						return (SNMP_ERR_COMMITFAILED);
					}					
					memset(&rruCfgMsgTable_RowBuf, 0, sizeof(rruCfgMsgTable_RowBuf));
					rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else if((rruCfgMsgTable_RowBuf.fin_flag_temp_thres == 0X03) && (rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE))
				{
					rru_param_temp_thres_msg.head.msg_type = MODULE_CFIG_MGMT;
					rru_param_temp_thres_msg.head.msg_code = SET_RRU_PARAM_TEMP_THRES;
					rru_param_temp_thres_msg.head.msg_len = rru_param_temp_thres_msg_len;
					rru_param_vswr_thres_msg.rru_id = rruCfgMsgTable_RowBuf.rruCfgMsgIndex;
					rru_param_temp_thres_msg.UpThres = rruCfgMsgTable_RowBuf.rruCfgMsgUpThres;
					rru_param_temp_thres_msg.LowThres = rruCfgMsgTable_RowBuf.rruCfgMsgLowThres;
					
					if(send_msg_to_om(MODULE_RRUS_MGMT, (char*)&rru_param_temp_thres_msg, rru_param_temp_thres_msg_len) != 0)
					{
						return (SNMP_ERR_COMMITFAILED);
					}					
					memset(&rruCfgMsgTable_RowBuf, 0, sizeof(rruCfgMsgTable_RowBuf));
					rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else if((rruCfgMsgTable_RowBuf.fin_flag_ant_cfg == 0X07) && (rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE))
				{
					rru_param_ant_cfg_msg.head.msg_type = MODULE_CFIG_MGMT;
					rru_param_ant_cfg_msg.head.msg_code = SET_RRU_PARAM_ANT_CFG;
					rru_param_ant_cfg_msg.head.msg_len = rru_param_ant_cfg_msg_len;
					rru_param_vswr_thres_msg.rru_id = rruCfgMsgTable_RowBuf.rruCfgMsgIndex;
					rru_param_ant_cfg_msg.AntMode = rruCfgMsgTable_RowBuf.rruCfgMsgAntMode;
					rru_param_ant_cfg_msg.AntSetNo = rruCfgMsgTable_RowBuf.rruCfgMsgAntSetNo;
					rru_param_ant_cfg_msg.AntState = rruCfgMsgTable_RowBuf.rruCfgMsgAntState;
					
					if(send_msg_to_om(MODULE_RRUS_MGMT, (UINT8*)&rru_param_ant_cfg_msg, rru_param_ant_cfg_msg_len) != 0)
					{
						return (SNMP_ERR_COMMITFAILED);
					}					
					memset(&rruCfgMsgTable_RowBuf, 0, sizeof(rruCfgMsgTable_RowBuf));
					rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else if((rruCfgMsgTable_RowBuf.fin_flag_channel_state == 0X03) && (rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus == SNMP_ROW_NOTINSERVICE)){
					
					rru_param_channel_state_msg.head.msg_type = MODULE_CFIG_MGMT;
					rru_param_channel_state_msg.head.msg_code = SET_RRU_PARAM_ANT_CFG;
					rru_param_channel_state_msg.head.msg_len = rru_param_channel_state_msg_len;
					rru_param_vswr_thres_msg.rru_id = rruCfgMsgTable_RowBuf.rruCfgMsgIndex;
					charVec2intVec(&rru_param_channel_state_msg.up_path_state, &rruCfgMsgTable_RowBuf.rruCfgMsgUpPathState, RRU_PATH_STATE_LEN);
				    charVec2intVec(&rru_param_channel_state_msg.dw_path_state, &rruCfgMsgTable_RowBuf.rruCfgMsgDwPathState, RRU_PATH_STATE_LEN);
					
					if(send_msg_to_om(MODULE_RRUS_MGMT, (UINT8*)&rru_param_channel_state_msg, rru_param_ant_cfg_msg_len) != 0)
					{
						return (SNMP_ERR_COMMITFAILED);
					}					
					memset(&rruCfgMsgTable_RowBuf, 0, sizeof(rruCfgMsgTable_RowBuf));
					rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else
					return (SNMP_ERR_COMMITFAILED);
				break;
			case SNMP_ROW_DESTROY:
				if((rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus != SNMP_ROW_NONEXISTENT) &&
					(rruCfgMsgTable_RowBuf.rruCfgMsgIndex == lIndex))
				{
					memset(&rruCfgMsgTable_RowBuf, 0, sizeof(rruCfgMsgTable_RowBuf));
					rruCfgMsgTable_RowBuf.rruCfgMsgRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else 
					return (SNMP_ERR_WRONGVALUE);
				break;
			default:
				return (SNMP_ERR_WRONGVALUE);
		}
		
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_rruLatestChannelSetRowStatus(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_rruAbilityMsgRowStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}
							 
int
write_rruSoftHardMsgRowStatus(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruDelayMeasureRowStatus(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruDealyCfgRruId(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruDealyCfgFiberNo(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruDealyCfgTable_RowBuf.rruDealyCfgIndex == lIndex))
        {
        	rruDealyCfgTable_RowBuf.rruDealyCfgFiberNo = value;
			setbit(rruDealyCfgTable_RowBuf.fin_flag,0);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruDealyCfgTrxaRxm(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruDealyCfgTable_RowBuf.rruDealyCfgIndex == lIndex))
        {
        	rruDealyCfgTable_RowBuf.rruDealyCfgTrxaRxm= value;
			setbit(rruDealyCfgTable_RowBuf.fin_flag,1);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruDealyCfgTrxmRxa(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruDealyCfgTable_RowBuf.rruDealyCfgIndex == lIndex))
        {
        	rruDealyCfgTable_RowBuf.rruDealyCfgTrxmRxa= value;
			setbit(rruDealyCfgTable_RowBuf.fin_flag,2);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;
        

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruDealyCfgTimeAdv(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruDealyCfgTable_RowBuf.rruDealyCfgIndex == lIndex))
        {
        	rruDealyCfgTable_RowBuf.rruDealyCfgTimeAdv= value;
			setbit(rruDealyCfgTable_RowBuf.fin_flag,3);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruDealyCfgDlCalRru(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruDealyCfgTable_RowBuf.rruDealyCfgIndex == lIndex))
        {
        	rruDealyCfgTable_RowBuf.rruDealyCfgDlCalRru= value;
			setbit(rruDealyCfgTable_RowBuf.fin_flag,4);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;
    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruDealyCfgUlCalRru(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruDealyCfgTable_RowBuf.rruDealyCfgIndex == lIndex))
        {
        	rruDealyCfgTable_RowBuf.rruDealyCfgUlCalRru= value;
			setbit(rruDealyCfgTable_RowBuf.fin_flag,5);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;
      

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruDealyCfgRowStatus(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

	
	long						lVar = 0;
	long						lIndex = 0;
	ICR_RRU_TIME_DELAY_CFG 		rru_time_delay_cfg_msg;
	INT32 						rru_time_delay_cfg_msg_len;
	rru_time_delay_cfg_msg_len = sizeof(ICR_RRU_TIME_DELAY_CFG);
	memset(&rru_time_delay_cfg_msg, 0, sizeof(rru_time_delay_cfg_msg));

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lVar = *(long *)var_val;
        if((lVar < 0) || (lVar > 6)) 
			return(SNMP_ERR_WRONGVALUE);
	    lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		switch(lVar)
		{
			case SNMP_ROW_CREATEANDWAIT:
				memset(&rruDealyCfgTable_RowBuf, 0x00, sizeof(rruDealyCfgTable_RowBuf));
				rruDealyCfgTable_RowBuf.rruDealyCfgIndex  = lIndex;
		  		rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus = SNMP_ROW_NOTINSERVICE;
			    break;
				
			case SNMP_ROW_ACTIVE:
				if((rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus == SNMP_ROW_NOTINSERVICE) && 
					(rruDealyCfgTable_RowBuf.fin_flag == 0X3F))
				{
					rru_time_delay_cfg_msg.head.msg_type = MODULE_CFIG_MGMT;
					rru_time_delay_cfg_msg.head.msg_code = SET_RRU_TIME_DELAY_CFG;
					rru_time_delay_cfg_msg.head.msg_len = rru_time_delay_cfg_msg_len;
					rru_time_delay_cfg_msg.rru_id = rruDealyCfgTable_RowBuf.rruDealyCfgIndex;
					rru_time_delay_cfg_msg.fiber_no = rruDealyCfgTable_RowBuf.rruDealyCfgFiberNo;
					rru_time_delay_cfg_msg.trxa_rxm = rruDealyCfgTable_RowBuf.rruDealyCfgTrxaRxm;
					rru_time_delay_cfg_msg.trxm_rxa = rruDealyCfgTable_RowBuf.rruDealyCfgTrxmRxa;
					rru_time_delay_cfg_msg.time_adv = rruDealyCfgTable_RowBuf.rruDealyCfgTimeAdv;
					rru_time_delay_cfg_msg.dl_cal_rru = rruDealyCfgTable_RowBuf.rruDealyCfgDlCalRru;
					rru_time_delay_cfg_msg.ul_cal_rru = rruDealyCfgTable_RowBuf.rruDealyCfgUlCalRru;
					
					if(send_msg_to_om(MODULE_RRUS_MGMT, (UINT8*)&rru_time_delay_cfg_msg, rru_time_delay_cfg_msg_len) != 0)
					{
						return (SNMP_ERR_COMMITFAILED);
					}					
					memset(&rruDealyCfgTable_RowBuf, 0, sizeof(rruDealyCfgTable_RowBuf));
					rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else
					return (SNMP_ERR_COMMITFAILED);
				break;
				
			case SNMP_ROW_DESTROY:
				if((rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus != SNMP_ROW_NONEXISTENT) &&
					(rruDealyCfgTable_RowBuf.rruDealyCfgIndex == lIndex))
				{
					memset(&rruDealyCfgTable_RowBuf, 0, sizeof(rruDealyCfgTable_RowBuf));
					rruDealyCfgTable_RowBuf.rruDealyCfgRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else 
					return (SNMP_ERR_WRONGVALUE);
				break;
			default:
				return (SNMP_ERR_WRONGVALUE);
		}
      
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruRingTestRruId(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruRingTestType(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruRingTestTable_RowBuf.rruRingTestRowStatus == SNMP_ROW_NOTINSERVICE) && (rruRingTestTable_RowBuf.rruRingTestIndex == lIndex))
        {
        	rruRingTestTable_RowBuf.rruRingTestType = value;
			setbit(rruRingTestTable_RowBuf.fin_flag,0);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;
        
    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruRingTestCheckPeriod(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruRingTestTable_RowBuf.rruRingTestRowStatus == SNMP_ROW_NOTINSERVICE) && (rruRingTestTable_RowBuf.rruRingTestIndex == lIndex))
        {
        	rruRingTestTable_RowBuf.rruRingTestType = value;
			setbit(rruRingTestTable_RowBuf.fin_flag,1);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;
        

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruRingTestPortNo(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruRingTestTable_RowBuf.rruRingTestRowStatus == SNMP_ROW_NOTINSERVICE) && (rruRingTestTable_RowBuf.rruRingTestIndex == lIndex))
        {
        	rruRingTestTable_RowBuf.rruRingTestType = value;
			setbit(rruRingTestTable_RowBuf.fin_flag,2);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;
        

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruRingTestRowStatus(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

	long						lVar = 0;
	long						lIndex = 0;
	ICR_RRU_RING_TEST 			rru_ring_test_msg;
	INT32 						rru_ring_test_msg_len;
	rru_ring_test_msg_len = sizeof(ICR_RRU_RING_TEST);
	memset(&rru_ring_test_msg, 0, sizeof(rru_ring_test_msg));

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        lVar = *(long *)var_val;
        if((lVar < 0) || (lVar > 6)) 
			return(SNMP_ERR_WRONGVALUE);
	    lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		switch(lVar)
		{
			case SNMP_ROW_CREATEANDWAIT:
				memset(&rruRingTestTable_RowBuf, 0x00, sizeof(rruRingTestTable_RowBuf));
				rruRingTestTable_RowBuf.rruRingTestIndex  = lIndex;
		  		rruRingTestTable_RowBuf.rruRingTestRowStatus = SNMP_ROW_NOTINSERVICE;
			    break;
				
			case SNMP_ROW_ACTIVE:
				if((rruRingTestTable_RowBuf.rruRingTestRowStatus == SNMP_ROW_NOTINSERVICE) && 
					(rruRingTestTable_RowBuf.fin_flag == 0X3F))
				{
					rru_ring_test_msg.head.msg_type = MODULE_CFIG_MGMT;
					rru_ring_test_msg.head.msg_code = SET_RRU_RING_TEST;
					rru_ring_test_msg.head.msg_len = rru_ring_test_msg_len;
					rru_ring_test_msg.rru_id = rruRingTestTable_RowBuf.rruRingTestIndex;
					rru_ring_test_msg.ring_test_type = rruRingTestTable_RowBuf.rruRingTestType;
					rru_ring_test_msg.check_period = rruRingTestTable_RowBuf.rruRingTestCheckPeriod;
					rru_ring_test_msg.port_no= rruRingTestTable_RowBuf.rruRingTestPortNo;
					
					if(send_msg_to_om(MODULE_RRUS_MGMT, (UINT8*)&rru_ring_test_msg, rru_ring_test_msg_len) != 0)
					{
						return (SNMP_ERR_COMMITFAILED);
					}					
					memset(&rruRingTestTable_RowBuf, 0, sizeof(rruRingTestTable_RowBuf));
					rruRingTestTable_RowBuf.rruRingTestRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else
					return (SNMP_ERR_COMMITFAILED);
				break;
				
			case SNMP_ROW_DESTROY:
				if((rruRingTestTable_RowBuf.rruRingTestRowStatus != SNMP_ROW_NONEXISTENT) &&
					(rruRingTestTable_RowBuf.rruRingTestIndex == lIndex))
				{
					memset(&rruRingTestTable_RowBuf, 0, sizeof(rruRingTestTable_RowBuf));
					rruRingTestTable_RowBuf.rruRingTestRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else 
					return (SNMP_ERR_WRONGVALUE);
				break;
			default:
				return (SNMP_ERR_WRONGVALUE);
		}
      
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruOperateResetType(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	
	long						lIndex = 0;
	ICR_RRU_RESET_REQ			rru_reset_req_msg;
	INT32						rru_reset_req_msg_len;
	rru_reset_req_msg_len = sizeof(ICR_RRU_RESET_REQ);
	memset(&rru_reset_req_msg, 0, sizeof(rru_reset_req_msg));

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		rru_reset_req_msg.head.msg_type = MODULE_CFIG_MGMT;
		rru_reset_req_msg.head.msg_code = SET_RRU_RESET_REQ;
		rru_reset_req_msg.head.msg_len = rru_reset_req_msg_len;
		rru_reset_req_msg.rru_id = lIndex;
		if(send_msg_to_om(MODULE_RRUS_MGMT, (UINT8*)&rru_reset_req_msg, rru_reset_req_msg_len) != 0)
		{
			return (SNMP_ERR_COMMITFAILED);
		}					
#if 0
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
		{
			rruInitMsgTable_RowBuf.rruInitMsgPeriod = value;
			setbit(rruInitMsgTable_RowBuf.FIN_FLAG,2);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
#endif
	   
		break;
     

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruOperateSwUpdate(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;


	long						lIndex = 0;
	ICR_RRU_SW_UPDATE_REQ		rru_sw_update_req_msg;
	INT32						rru_sw_update_req_msg_len;
	rru_sw_update_req_msg_len = sizeof(rru_sw_update_req_msg);
	memset(&rru_sw_update_req_msg, 0, sizeof(rru_sw_update_req_msg));

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUCONFIGINFOTABLES_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		rru_sw_update_req_msg.head.msg_type = MODULE_CFIG_MGMT;
		rru_sw_update_req_msg.head.msg_code = SET_RRU_SOFTWARE_UPDATE_REQ;
		rru_sw_update_req_msg.head.msg_len = rru_sw_update_req_msg_len;
		rru_sw_update_req_msg.rru_id = lIndex;
		if(send_msg_to_om(MODULE_RRUS_MGMT, (UINT8*)&rru_sw_update_req_msg, rru_sw_update_req_msg_len) != 0)
		{
			return (SNMP_ERR_COMMITFAILED);
		}					
#if 0
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
		{
			rruInitMsgTable_RowBuf.rruInitMsgPeriod = value;
			setbit(rruInitMsgTable_RowBuf.FIN_FLAG,2);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
#endif
	   
		break;
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruOperateRowStatus(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}
