/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:33 CST. */
/* 
 Copyright (C) Rong Tao @Beijing

 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.3
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
 Texts. A copy of the license is included in the section entitled ‘‘GNU
 Free Documentation License’’.
   2019年 03月 14日 星期四 19:24:45 CST. 
*/
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 08日 星期五 08:10:29 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:28:04 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#if 1//2018.09.27 zhaozhg

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "vcmCommConfigInfo.h"
#include "cell_mgmt_api.h"

extern INT32 get_virtual_cell_num();

#define VCMCOMMCONFIGINFO_INDEX_POS 13
oid             vcmCommConfigInfo_variables_oid[] =
    { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 4 };

/*
 * variable4 vcmCommConfigInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the vcmCommConfigInfo mib section 
 */

struct variable4 vcmCommConfigInfo_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */

#define VCMCOMMCONFIGINFOINDEX		1
    {VCMCOMMCONFIGINFOINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_vcmCommConfigInfoTable, 3, {1, 1, 1}},
#define VCMCOMMCONFIGINFOGID		2
    {VCMCOMMCONFIGINFOGID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_vcmCommConfigInfoTable, 3, {1, 1, 2}},
#define VCMCOMMCONFIGINFOMODE		3
    {VCMCOMMCONFIGINFOMODE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_vcmCommConfigInfoTable, 3, {1, 1, 3}},
#define VCMCOMMCONFIGINFOBANDWIDTH		4
    {VCMCOMMCONFIGINFOBANDWIDTH, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_vcmCommConfigInfoTable, 3, {1, 1, 4}},
#define VCMCOMMCONFIGINFOISUNI		5
    {VCMCOMMCONFIGINFOISUNI, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_vcmCommConfigInfoTable, 3, {1, 1, 6}},
#define VCMCOMMCONFIGINFORRUID		6
    {VCMCOMMCONFIGINFORRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_vcmCommConfigInfoTable, 3, {1, 1, 7}},
#define VCMCOMMCONFIGINFORRUIP		7
    {VCMCOMMCONFIGINFORRUIP, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_vcmCommConfigInfoTable, 3, {1, 1, 8}},
#define VCMCOMMCONFIGINFORRUPORT		8
    {VCMCOMMCONFIGINFORRUPORT, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_vcmCommConfigInfoTable, 3, {1, 1, 9}},
#define VCMCOMMCONFIGINFOROWSTATUS		9
    {VCMCOMMCONFIGINFOROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_vcmCommConfigInfoTable, 3, {1, 1, 10}},
#define VCMCOMMCONFIGINFORRUSN         10
    {VCMCOMMCONFIGINFORRUSN, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_vcmCommConfigInfoTable, 3, {1, 1, 11}},
};

/*
 * (L = length of the oidsuffix) 
 */
static struct
{
ulong   ulIndex;
ulong   ulRowStatus;   //0为ROW_NONEXISTENT, 1为ROW_NOTINSEVICE
ulong   ulGCellId;
ulong   ulMode;
ulong   ulBandWidth;
ulong   ulIsUni;
ulong   ulRRUId;
ulong   ulRRUPort;
char    sMacCfgPth[STR_LEN_256];
char    sRRUIP[STR_LEN_16];
char    sRRUSN[STR_LEN_16];
} vcm_cellInfo_RowBuf;


/** Initializes the vcmCommConfigInfo module */
void
init_vcmCommConfigInfo(void)
{

    DEBUGMSGTL(("vcmCommConfigInfo", "Initializing\n"));

    REGISTER_MIB("vcmCommConfigInfo", vcmCommConfigInfo_variables,
                 variable4, vcmCommConfigInfo_variables_oid);

    memset(&vcm_cellInfo_RowBuf,0,sizeof(vcm_cellInfo_RowBuf));
}
/* vcmCommConfigInfoTable表索引处理数 */
long header_vcmCommConfigInfoTable
(
    struct variable *vp,
    oid             *name,
    size_t          *length,
    int              exact,
    size_t          *var_len,
    WriteMethod    **write_method,
    long            *plIndex
)
{
    long   ret         = 0;
    long   lComp       = MATCH_FAILED;
    long   lIndex      = 0;
    oid    newname[MAX_OID_LEN];

    memset(newname, 0x00, sizeof(newname));
    memcpy(newname, name, (*length) * sizeof(oid));

    if(exact)  /* get/set  */
    {
        ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
        if((ret == 0) && (*length == (vp->namelen + 1)))
		{
	        lIndex = newname[vp->namelen];
		    if((lIndex > 0) && (lIndex <= MAX_VCM_CELL_SUM)) lComp = MATCH_SUCCEEDED;
        }
    }
    else        /* get-next */
    {
        ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);

		if(ret < 0)                         /* name中的OID比注册信息中的OID靠前 */
        {
            memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));

            if(get_first_cell_index(&lIndex) == SUCCESS)
            {

                lComp = MATCH_SUCCEEDED;
            }
			else
			{                               /* 如果行缓冲区中有数据，则提取该索引 */
                if(vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NONEXISTENT)
                {
					lComp  = MATCH_SUCCEEDED;
                    lIndex = (ulong)vcm_cellInfo_RowBuf.ulIndex;
                }
			}
        }
        else if(ret == 0)
        {
            if(*length == vp->namelen)    /* 没有带索引   */
            {
                if(get_first_cell_index(&lIndex) == SUCCESS)
                {
                    lComp = MATCH_SUCCEEDED;
                }
			    else
			    {                         /* 如果行缓冲区中有数据，则提取该索引 */
                    if(vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NONEXISTENT)
                    {
					    lComp  = MATCH_SUCCEEDED;
                        lIndex = (ulong)vcm_cellInfo_RowBuf.ulIndex;
                    }
		  	    }
            }
            else if (*length == (vp->namelen + 1)) /* 有参照索引   */
            {
                lIndex = newname[vp->namelen];
				if((vcm_cellInfo_RowBuf.ulRowStatus == SNMP_ROW_NONEXISTENT) ||
				   (vcm_cellInfo_RowBuf.ulIndex  != lIndex))
                {

                    if(get_next_cell_index(&lIndex) == SUCCESS)
                    {
                        lComp  = MATCH_SUCCEEDED;
                    }
			        else
			        {                               /* 如果行缓冲区中有数据，则提取该索引 */
                        if(vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NONEXISTENT)
                        {
					        lComp  = MATCH_SUCCEEDED;
                            lIndex = (ulong)vcm_cellInfo_RowBuf.ulIndex;
                        }
		  	        }
                }
            }
        }
    }

	if(lComp == MATCH_SUCCEEDED)
	{
       *length  = vp->namelen + 1;
       *plIndex = lIndex;
        newname[vp->namelen] = lIndex;
        memcpy(name, newname, (*length) * sizeof(oid));
	}

    return(lComp);
}
/*
 * var_vcmCommConfigInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_vcmCommConfigInfo above.
 */
unsigned char  *
var_vcmCommConfigInfoTable(struct variable *vp,
                           oid * name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;
	static MsgCfigCellSetupReq queryInfo;
	static MsgCfigCellSetupReq setupInfo;

	static unsigned long ulVar;
    static unsigned char sMacCfgPth[STR_LEN_256];
	static unsigned char sRruIp[STR_LEN_16];
	static unsigned char sRruSN[STR_LEN_16];
	
	long         ret    = 0,lret = 0,queryret = 0;
	long         lIndex = 0,ulIfIndex=0;
	long         flag   = 0;
	long         haveok = 0;
	

    ret = header_vcmCommConfigInfoTable(vp,name,length,exact,var_len,write_method, &lIndex);
    if (ret != MATCH_SUCCEEDED)
    {
        return (unsigned char *)NULL;
    }
    haveok = cell_index_exist(&lIndex);

    if(exact)
    {
    	//get set
    	if ((haveok == SUCCESS) || (vp->magic == VCMCOMMCONFIGINFOROWSTATUS) || 
			((vcm_cellInfo_RowBuf.ulRowStatus == SNMP_ROW_NOTINSERVICE)&& (vcm_cellInfo_RowBuf.ulIndex == lIndex)))
    		{
    		    if ( haveok == SUCCESS) 
					flag = 1;
    		}
			else
			{
                return ((unsigned char  *)NULL);
			}

    }
    else
    {
    	//get-next
	    if( haveok == SUCCESS)
		flag = 1;

    }

	//查询
	if( flag == 1 )
	{
		queryret=get_virtual_cell_info ( lIndex, &queryInfo);
	}
    
    switch (vp->magic) {
    case VCMCOMMCONFIGINFOINDEX:
        ulVar= lIndex;    
	    *var_len = sizeof(ulVar);
        return ((unsigned char *) & ulVar);
    case VCMCOMMCONFIGINFOGID:
        *write_method = write_vcmCommConfigInfoGID;
	    if (flag)
	    {
	        if ( queryret != SUCCESS)
	        {
	            *var_len = 0;
				return ((unsigned char *) NULL);
	        }
			else 
			{
		         	
	   		    ulVar = queryInfo.global_cell_id;
			}
	    }
		else
		{   
		    ulVar = vcm_cellInfo_RowBuf.ulGCellId;
		}
		*var_len = sizeof(ulVar);
        return ((unsigned char *) & ulVar);
    case VCMCOMMCONFIGINFOMODE:
        *write_method = write_vcmCommConfigInfoMode;
	    if (flag)
	    {
	        if ( queryret != SUCCESS)
	        {
	            *var_len = 0;
				return ((unsigned char *) NULL);
	        }
			else 
			{
		         	
	   		    ulVar = queryInfo.cell_mode;
			}
	    }
		else
		{   
		    ulVar = vcm_cellInfo_RowBuf.ulMode;
		}
		*var_len = sizeof(ulVar);
        return ((unsigned char *) & ulVar);
    case VCMCOMMCONFIGINFOBANDWIDTH:
        *write_method = write_vcmCommConfigInfoBandWidth;
	    if (flag)
	    {
	        if ( queryret != SUCCESS)
	        {
	            *var_len = 0;
				return ((unsigned char *) NULL);
	        }
			else 
			{
		         	
	   		    ulVar = queryInfo.cell_bandwidth;
			}
	    }
		else
		{   
		    ulVar = vcm_cellInfo_RowBuf.ulBandWidth;
		}
		*var_len = sizeof(ulVar);
        return ((unsigned char *) & ulVar);		
    case VCMCOMMCONFIGINFOISUNI:
        *write_method = write_vcmCommConfigInfoIsUni;
	    if (flag)
	    {
	        if ( queryret != SUCCESS)
	        {
	            *var_len = 0;
				return ((unsigned char *) NULL);
	        }
			else 
			{
		         	
	   		    ulVar = queryInfo.cell_is_uni;
			}
	    }
		else
		{   
		    ulVar = vcm_cellInfo_RowBuf.ulIsUni;
		}
		*var_len = sizeof(ulVar);
        return ((unsigned char *) & ulVar);	

    case VCMCOMMCONFIGINFORRUID:
        *write_method = write_vcmCommConfigInfoRRUID;
	    if (flag)
	    {
	        if ( queryret != SUCCESS)
	        {
	            *var_len = 0;
				return ((unsigned char *) NULL);
	        }
			else 
			{
		         	
	   		    ulVar = queryInfo.rru_item.rru_id;
			}
	    }
		else
		{   
		    ulVar = vcm_cellInfo_RowBuf.ulRRUId;
		}
		*var_len = sizeof(ulVar);
        return ((unsigned char *) & ulVar);	
    case VCMCOMMCONFIGINFORRUIP:
        *write_method = write_vcmCommConfigInfoRRUIP;
        if (flag)
        {
            if (queryret != SUCCESS)
            {
                *var_len = 0;
				return ((unsigned char *)NULL);
            }
			else
			{
			    memcpy(sRruIp, queryInfo.rru_item.rru_ip, STR_LEN_16);
			}

		}
		else
		{
		    memcpy(sRruIp, vcm_cellInfo_RowBuf.sRRUIP, STR_LEN_16);
		}
		*var_len = STR_LEN_16;
        return (u_char *) sRruIp;
    case VCMCOMMCONFIGINFORRUPORT:
        *write_method = write_vcmCommConfigInfoRRUPort;
	    if (flag)
	    {
	        if ( queryret != SUCCESS)
	        {
	            *var_len = 0;
				return ((unsigned char *) NULL);
	        }
			else 
			{
		         	
	   		    ulVar = queryInfo.rru_item.rru_port;
			}
	    }
		else
		{   
		    ulVar = vcm_cellInfo_RowBuf.ulRRUPort;
		}
		*var_len = sizeof(ulVar);
        return ((unsigned char *) & ulVar);	

    case VCMCOMMCONFIGINFOROWSTATUS:
        *write_method = write_vcmCommConfigInfoRowStatus;
		 if(flag)
		 {
			  ulVar = SNMP_ROW_ACTIVE;
		 }
		 else
		 {
			 ulVar = vcm_cellInfo_RowBuf.ulRowStatus;
		 }
		*var_len = sizeof(ulVar);
		 return((unsigned char *)&ulVar);
    case VCMCOMMCONFIGINFORRUSN:
        *write_method = write_vcmCommConfigInfoRRUSN;
        if (flag)
        {
            if (queryret != SUCCESS)
            {
                *var_len = 0;
       			return ((unsigned char *)NULL);
            }
       		else
       		{
       			memcpy(sRruSN, queryInfo.rru_item.rru_sn, STR_LEN_16);
       		}

       	}
       	else
       	{
       		memcpy(sRruSN, vcm_cellInfo_RowBuf.sRRUSN, STR_LEN_16);
       	}
       	*var_len = STR_LEN_16;
        return (u_char *) sRruSN;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_vcmCommConfigInfoGID(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
	u_long          ulIndex = 0;
	u_long          value;
    int             size;
	ulIndex = (unsigned long) name[VCMCOMMCONFIGINFO_INDEX_POS];
	
    if((vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NOTINSERVICE) ||
	   (vcm_cellInfo_RowBuf.ulIndex  != ulIndex)) 	return(SNMP_ERR_WRONGVALUE);	

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr,
                    "write to vcmCommConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to vcmCommConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
	    value = *(u_long *)var_val;
        break;

    case FREE:

        break;

    case ACTION:

		vcm_cellInfo_RowBuf.ulGCellId = *(u_long *)var_val;
		break;

        
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_vcmCommConfigInfoMode(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
	u_long          ulIndex = 0;
    int             size;
	ulIndex = (unsigned long) name[VCMCOMMCONFIGINFO_INDEX_POS];
	
    if((vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NOTINSERVICE) ||
	   (vcm_cellInfo_RowBuf.ulIndex  != ulIndex)) 	return(SNMP_ERR_WRONGVALUE);

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr,
                    "write to vcmCommConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to vcmCommConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        vcm_cellInfo_RowBuf.ulMode = *(u_long *) var_val;
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_vcmCommConfigInfoBandWidth(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	u_long          ulIndex = 0;
	ulIndex = (unsigned long) name[VCMCOMMCONFIGINFO_INDEX_POS];
	
    if((vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NOTINSERVICE) ||
	   (vcm_cellInfo_RowBuf.ulIndex  != ulIndex)) 	return(SNMP_ERR_WRONGVALUE);

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr,
                    "write to vcmCommConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to vcmCommConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        vcm_cellInfo_RowBuf.ulBandWidth = *(u_long *) var_val;
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_vcmCommConfigInfoIsUni(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	u_long          ulIndex = 0;
	ulIndex = (unsigned long) name[VCMCOMMCONFIGINFO_INDEX_POS];

    if((vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NOTINSERVICE) ||
	   (vcm_cellInfo_RowBuf.ulIndex  != ulIndex)) 	return(SNMP_ERR_WRONGVALUE);

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr,
                    "write to vcmCommConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to vcmCommConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        vcm_cellInfo_RowBuf.ulIsUni = *(u_long *) var_val;
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_vcmCommConfigInfoRRUID(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	u_long          ulIndex = 0;
	ulIndex = (unsigned long) name[VCMCOMMCONFIGINFO_INDEX_POS];

    if((vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NOTINSERVICE) ||
	   (vcm_cellInfo_RowBuf.ulIndex  != ulIndex)) 	return(SNMP_ERR_WRONGVALUE);

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr,
                    "write to vcmCommConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to vcmCommConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        vcm_cellInfo_RowBuf.ulRRUId = *(u_long *) var_val;
         
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_vcmCommConfigInfoRRUIP(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	u_long          ulIndex = 0;
	ulIndex = (unsigned long) name[VCMCOMMCONFIGINFO_INDEX_POS];
    if((vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NOTINSERVICE) ||
	   (vcm_cellInfo_RowBuf.ulIndex  != ulIndex)) 	return(SNMP_ERR_WRONGVALUE);

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr,
                    "write to vcmCommConfigInfo not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
//        if (var_val_len > sizeof(char)) {
//            fprintf(stderr, "write to vcmCommConfigInfo: bad length\n");
//            return SNMP_ERR_WRONGLENGTH;
//        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
	    memset(vcm_cellInfo_RowBuf.sRRUIP, 0, STR_LEN_PROTOCOL_16);
		memcpy(vcm_cellInfo_RowBuf.sRRUIP, var_val,var_val_len);
        break;

    case UNDO:

        break;

    case COMMIT:

        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_vcmCommConfigInfoRRUPort(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	u_long          ulIndex = 0;
	ulIndex = (unsigned long) name[VCMCOMMCONFIGINFO_INDEX_POS];

    if((vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NOTINSERVICE) ||
	   (vcm_cellInfo_RowBuf.ulIndex  != ulIndex)) 	return(SNMP_ERR_WRONGVALUE);

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr,
                    "write to vcmCommConfigInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to vcmCommConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        vcm_cellInfo_RowBuf.ulRRUPort = *(u_long *) var_val;
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_vcmCommConfigInfoRRUSN(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	u_long          ulIndex = 0;
	ulIndex = (unsigned long) name[VCMCOMMCONFIGINFO_INDEX_POS];
    if((vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NOTINSERVICE) ||
	   (vcm_cellInfo_RowBuf.ulIndex  != ulIndex)) 	return(SNMP_ERR_WRONGVALUE);

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr,
                    "write to vcmCommConfigInfo not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
//        if (var_val_len > sizeof(char)) {
//            fprintf(stderr, "write to vcmCommConfigInfo: bad length\n");
//            return SNMP_ERR_WRONGLENGTH;
//        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
	    memset(vcm_cellInfo_RowBuf.sRRUSN, 0, STR_LEN_PROTOCOL_16);
		memcpy(vcm_cellInfo_RowBuf.sRRUSN, var_val,var_val_len);
        break;

    case UNDO:

        break;

    case COMMIT:

        break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_vcmCommConfigInfoRowStatus(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    u_long            ulIndex;
	long            lVar;
    long            value;
    int             size;
    MsgCfigCellSetupReq  sCellMsg;
    MsgCfigCellDelReq sDelCellMsg;
	memset(&sDelCellMsg, 0x00,sizeof(sDelCellMsg));
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr,
                    "write to vcmCommConfigInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to vcmCommConfigInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
	         lVar = *(long *)var_val;
		     if((lVar < 0) || (lVar > 6)) return(SNMP_ERR_WRONGVALUE);
	         ulIndex = name[VCMCOMMCONFIGINFO_INDEX_POS];	 

			switch(lVar)
			{
				case SNMP_ROW_CREATEANDWAIT: 
					if(cell_index_exist(&ulIndex) == SUCCESS)
					{
					    return(SNMP_ERR_WRONGVALUE);
					}

					memset(&vcm_cellInfo_RowBuf, 0x00, sizeof(vcm_cellInfo_RowBuf));

					vcm_cellInfo_RowBuf.ulIndex  = ulIndex;

					vcm_cellInfo_RowBuf.ulRowStatus = SNMP_ROW_NOTINSERVICE;
                    break;
				case SNMP_ROW_ACTIVE: 
					if((vcm_cellInfo_RowBuf.ulRowStatus == SNMP_ROW_NOTINSERVICE) )
					{
					    memset(&sCellMsg, 0x00, sizeof(sCellMsg));
					    sCellMsg.msghead.msg_type= MODULE_CFIG_MGMT;
					    sCellMsg.msghead.msg_code= CFIG_MGMT_MSG_VC_SETUP_REQ;
					    sCellMsg.msghead.msg_len = sizeof(MsgCfigCellSetupReq);
					    sCellMsg.cell_snmp_index = vcm_cellInfo_RowBuf.ulIndex;
						sCellMsg.cell_bandwidth = vcm_cellInfo_RowBuf.ulBandWidth;
						sCellMsg.cell_mode = vcm_cellInfo_RowBuf.ulMode;
						sCellMsg.cell_is_uni = vcm_cellInfo_RowBuf.ulIsUni;
						sCellMsg.global_cell_id = vcm_cellInfo_RowBuf.ulGCellId;
						sCellMsg.rru_item.rru_id = vcm_cellInfo_RowBuf.ulRRUId;
						sCellMsg.rru_item.rru_port = vcm_cellInfo_RowBuf.ulRRUPort;
						memcpy(sCellMsg.rru_item.rru_ip, vcm_cellInfo_RowBuf.sRRUIP, STR_LEN_16);
						memcpy(sCellMsg.rru_item.rru_sn, vcm_cellInfo_RowBuf.sRRUSN, STR_LEN_16);
						memcpy(sCellMsg.mac_cfg_pth, g_proCfgDicTable[ulIndex-1].pro_cfg_dic,sizeof( g_proCfgDicTable[ulIndex].pro_cfg_dic));

					    printf("sCellMsg.stSysMsg.msg_type is %d\n",sCellMsg.msghead.msg_type);
					    printf("sCellMsg.stSysMsg.msg_code is %d\n",sCellMsg.msghead.msg_code);
					    printf("sCellMsg.stSysMsg.msg_len is %d\n",sCellMsg.msghead.msg_len);
					    printf("sCellMsg.cell_index is %d\n",sCellMsg.cell_snmp_index );
					    printf("sCellMsg.cell_bandwidth is %d\n",sCellMsg.cell_bandwidth );
					    printf("sCellMsg.cell_mode is %d\n",sCellMsg.cell_mode );
					    printf("sCellMsg.cell_is_uni is %d\n",sCellMsg.cell_is_uni );
					    printf("sCellMsg.global_cell_id is %d\n",sCellMsg.global_cell_id );
					    printf("sCellMsg.rru_item.rru_id is %d\n",sCellMsg.rru_item.rru_id );
					    printf("sCellMsg.rru_item.rru_port is %d\n",sCellMsg.rru_item.rru_port );
					    printf("sCellMsg.rru_item.rru_ip is %s\n",sCellMsg.rru_item.rru_ip );
					    printf("sCellMsg.rru_item.rru_sn is %s\n",sCellMsg.rru_item.rru_sn );
					    printf("sCellMsg.mac_cfg_pth is %s\n",sCellMsg.mac_cfg_pth );
				        if (send_msg_to_om(MODULE_CELL_MGMT,(char*)&sCellMsg,sizeof(MsgCfigCellSetupReq)) != 0)
				        {
				        	return SNMP_ERR_COMMITFAILED;
				        }
//				        send_msg_to_om(MODULE_CELL_MGMT,(char*)&sCellMsg,sizeof(CellSetupReqMsg));
						memset(&vcm_cellInfo_RowBuf, 0x00, sizeof(vcm_cellInfo_RowBuf));
						vcm_cellInfo_RowBuf.ulRowStatus = SNMP_ROW_NONEXISTENT;	
					}
					else return (SNMP_ERR_COMMITFAILED);
					break;

				case SNMP_ROW_DESTROY:  /* destroy不成功应该返回SNMP_ERR_WRONGVALUE*/
					if((vcm_cellInfo_RowBuf.ulRowStatus != SNMP_ROW_NONEXISTENT) &&
						(vcm_cellInfo_RowBuf.ulIndex == ulIndex))
					{
						memset(&vcm_cellInfo_RowBuf, 0x0, sizeof(vcm_cellInfo_RowBuf));
						vcm_cellInfo_RowBuf.ulRowStatus = SNMP_ROW_NONEXISTENT;
					}
					else
					{
						sDelCellMsg.msghead.msg_type= MODULE_CFIG_MGMT;
					    sDelCellMsg.msghead.msg_code= CFIG_MGMT_MSG_VC_DEL_REQ;
					    sDelCellMsg.msghead.msg_len = sizeof(MsgCfigCellDelReq);
					    sDelCellMsg.cell_snmp_index = ulIndex;

					    printf("sDelCellMsg.stSysMsg.msg_type is %d\n",sDelCellMsg.msghead.msg_type);
					    printf("sDelCellMsg.stSysMsg.msg_code is %d\n",sDelCellMsg.msghead.msg_code);
					    printf("sDelCellMsg.stSysMsg.msg_len is %d\n",sDelCellMsg.msghead.msg_len);
					    printf("sCellsDelCellMsgMsg.cell_index is %d\n",sDelCellMsg.cell_snmp_index );

				        if (send_msg_to_om(MODULE_CELL_MGMT,(char*)&sCellMsg,sizeof(MsgCfigCellDelReq)) != 0)
				        {
				        	return SNMP_ERR_COMMITFAILED;
				        }
//				        send_msg_to_om(MODULE_CELL_MGMT,(char*)&sCellMsg,sizeof(CellDeleteReqMsg));
					}
					break;

				default: 
					return (SNMP_ERR_WRONGVALUE);
			}
			break;        
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}
#endif
