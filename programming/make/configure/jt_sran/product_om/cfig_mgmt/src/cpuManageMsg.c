/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:33 CST. */
/* 
 Copyright (C) Rong Tao @Beijing

 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.3
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
 Texts. A copy of the license is included in the section entitled ‘‘GNU
 Free Documentation License’’.
   2019年 03月 14日 星期四 19:24:45 CST. 
*/
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 08日 星期五 08:10:29 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:28:04 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "cpuManageMsg.h"

/*
 * cpuManageMsg_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
//extern INT32 CTRL_CPU_Device_Get_cpu_id(UINT32 index,UINT32 *value);
//extern INT32 CTRL_CPU_Device_Get_cpu_name(UINT32 index,char *value,UINT32 ulength);
//extern INT32 CTRL_CPU_Device_Get_bios_version(UINT32 index,char *value,UINT32 ulength);
//
//extern INT32 CTRL_CPU_Device_Get_bmc_id(UINT32 *value);
//extern INT32 CTRL_CPU_Device_Get_bmc_name(char *value,UINT32 ulength);
//extern INT32 CTRL_CPU_Device_Get_bmc_fw_version(char *value,UINT32 ulength);
//extern INT32 CTRL_CPU_Device_Get_bmc_addr(char *addr,UINT32 ulength);
//
///*cpu  server---health information get api*/
//
//extern INT32 CTRL_CPU_Health_Get_cpu_server_id(UINT32 *value);
//extern INT32 CTRL_CPU_Health_Get_cpu_server_fan_thres(UINT32 *value);
//extern INT32 CTRL_CPU_Health_Get_old_cpu_server_fan_thres(UINT32 *value);
//extern INT32 CTRL_CPU_Health_Get_cpu_server_fan(UINT32 *value);
//
//extern INT32 CTRL_CPU_HealthInfo_Get_cpu_id(UINT32 index,UINT32 *value);
//extern INT32 CTRL_CPU_HealthInfo_Get_cpu_temp_thres(UINT32 index,UINT32 *value);
//extern INT32 CTRL_CPU_HealthInfo_Get_old_cpu_temp_thres(UINT32 index,UINT32 *value);
//extern INT32 CTRL_CPU_HealthInfo_Get_cpu_temp(UINT32 index,UINT32 *value);
//extern INT32 CTRL_CPU_HealthInfo_Get_cpu_vol_thres(UINT32 index,UINT32 *value);
//extern INT32 CTRL_CPU_HealthInfo_Get_old_cpu_vol_thres(UINT32 index,UINT32 *value);
//extern INT32 CTRL_CPU_HealthInfo_Get_cpu_vol(UINT32 index,UINT32 *value);
//
///*cpu  server---computing information get api*/
//
//extern INT32 CTRL_CPU_Cal_Get_cpu_server_id(UINT32 *value);
//extern INT32 CTRL_CPU_Cal_Get_cpu_usg_thres(float *value);
//extern INT32 CTRL_CPU_Cal_Get_old_cpu_usg_thres(float *value);
//extern INT32 CTRL_CPU_Cal_Get_cpu_usg(float *value);
//extern INT32 CTRL_CPU_Cal_Get_mem_usg_thres(float *value);
//extern INT32 CTRL_CPU_Cal_Get_old_mem_usg_thres(float *value);
//extern INT32 CTRL_CPU_Cal_Get_mem_usg(float *value);

#define CPUMANAGE_INDEX_POS 15
oid             cpuManageMsg_variables_oid[] =
    { 1, 3, 6, 1, 4, 1, 12001, 1, 2, 3, 2, 2 };
/*
 * variable4 cpuManageMsg_variables:
 *   this variable defines function callbacks and type return information 
 *   for the cpuManageMsg mib section 
 */

struct variable4 cpuManageMsg_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */
#define CPUASSETMSGCPUSERVERID		1
    {CPUASSETMSGCPUSERVERID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {1, 1}},
#define CPUASSETMSGBMCID		2
    {CPUASSETMSGBMCID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {1, 4}},
#define CPUASSETMSGBMCNAME		3
    {CPUASSETMSGBMCNAME, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {1, 5}},
#define CPUASSETMSGBMCFWVERSION		4
    {CPUASSETMSGBMCFWVERSION, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {1, 6}},
#define CPUASSETMSGBMCADDR		5
    {CPUASSETMSGBMCADDR, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {1, 7}},
#define CPUHEALTHMSGCPUSERVERID		6
    {CPUHEALTHMSGCPUSERVERID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {2, 1}},
#define CPUHEALTHMSGCPUSERVERFANTHRES		7
    {CPUHEALTHMSGCPUSERVERFANTHRES, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {2, 2}},
#define CPUHEALTHMSGCPUSERVERFAN		8
    {CPUHEALTHMSGCPUSERVERFAN, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {2, 3}},
#define COMPUTERESMSGCPUSERVERID		9
    {COMPUTERESMSGCPUSERVERID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {3, 1}},
#define COMPUTERESMSGCPUUSGTHRES		10
    {COMPUTERESMSGCPUUSGTHRES, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {3, 2}},
#define COMPUTERESMSGCPUUSG		11
    {COMPUTERESMSGCPUUSG, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {3, 3}},
#define COMPUTERESMSGMEMUSGTHRES		12
    {COMPUTERESMSGMEMUSGTHRES, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {3, 4}},
#define COMPUTERESMSGMEMUSG		13
    {COMPUTERESMSGMEMUSG, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuManageMsg, 2, {3, 5}},

#define CPUASSETMSGINDEX		1
    {CPUASSETMSGINDEX, ASN_UNSIGNED, NETSNMP_OLDAPI_RONLY,
     var_cpuAssetMsgTable, 4, {1, 8, 1, 1}},
#define CPUASSETMSGCPUNAME		2
    {CPUASSETMSGCPUNAME, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_cpuAssetMsgTable, 4, {1, 8, 1, 2}},
#define CPUASSETMSGBIOSVERSION		3
    {CPUASSETMSGBIOSVERSION, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_cpuAssetMsgTable, 4, {1, 8, 1, 3}},
#define CPUASSETMSGROWSTATUS		4
    {CPUASSETMSGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cpuAssetMsgTable, 4, {1, 8, 1, 4}},
#define CPUHEALTHMSGINDEX		1
    {CPUHEALTHMSGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_cpuHealthMsgTable, 4, {2, 4, 1, 1}},
#define CPUHEALTHMSGCPUID		2
    {CPUHEALTHMSGCPUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuHealthMsgTable, 4, {2, 4, 1, 2}},
#define CPUHEALTHMSGTEMPTHRES		3
    {CPUHEALTHMSGTEMPTHRES, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuHealthMsgTable, 4, {2, 4, 1, 3}},
#define CPUHEALTHMSGTEMP		4
    {CPUHEALTHMSGTEMP, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuHealthMsgTable, 4, {2, 4, 1, 4}},
#define CPUHEALTHMSGVOLTHRES		5
    {CPUHEALTHMSGVOLTHRES, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuHealthMsgTable, 4, {2, 4, 1, 5}},
#define CPUHEALTHMSGVOL		6
    {CPUHEALTHMSGVOL, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_cpuHealthMsgTable, 4, {2, 4, 1, 6}},
#define CPUHEALTHMSGROWSTATUS		7
    {CPUHEALTHMSGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_cpuHealthMsgTable, 4, {2, 4, 1, 7}},
};

/*
 * (L = length of the oidsuffix) 
 */


/** Initializes the cpuManageMsg module */
void
init_cpuManageMsg(void)
{

    DEBUGMSGTL(("cpuManageMsg", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("cpuManageMsg", cpuManageMsg_variables, variable4,
                 cpuManageMsg_variables_oid);

    /*
     * place any other initialization junk you need here 
     */
}

/*
 * var_cpuManageMsg():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_cpuManageMsg(struct variable *vp,
                 oid * name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    static unsigned long ulVar;
	static unsigned char sName[STR_LEN_48];	
	static unsigned char sVersion[STR_LEN_16];
    static unsigned char sBmcName[STR_LEN_24];
	static unsigned char sBmcVersion[STR_LEN_24];
	static unsigned char sBmcAddr[STR_LEN_16];

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CPUASSETMSGCPUSERVERID:
        *write_method = write_cpuAssetMsgCpuServerId;
	    long_ret= CTRL_CPU_Health_Get_cpu_server_id(&ulVar);
	    *var_len = sizeof(ulVar);
	    return (u_char *) & ulVar;
    case CPUASSETMSGBMCID:
        *write_method = write_cpuAssetMsgBmcId;
	    long_ret= CTRL_CPU_Device_Get_bmc_id(&ulVar);
	    *var_len = sizeof(ulVar);
	    return (u_char *) & ulVar;

    case CPUASSETMSGBMCNAME:
        *write_method = write_cpuAssetMsgBmcName;
		long_ret= CTRL_CPU_Device_Get_bmc_name(sBmcName,STR_LEN_24);
	    *var_len = STR_LEN_24;
        return (u_char *)sBmcName;

    case CPUASSETMSGBMCFWVERSION:
        *write_method = write_cpuAssetMsgBmcFwVersion;
		long_ret= CTRL_CPU_Device_Get_bmc_fw_version(sBmcVersion,STR_LEN_24);
	    *var_len = STR_LEN_24;
        return (u_char *)sBmcVersion;

    case CPUASSETMSGBMCADDR:
        *write_method = write_cpuAssetMsgBmcAddr;
		long_ret= CTRL_CPU_Device_Get_bmc_addr(sBmcAddr,STR_LEN_16);
	    *var_len = STR_LEN_16;
        return (u_char *)sBmcAddr;

    case CPUHEALTHMSGCPUSERVERID:
        *write_method = write_cpuHealthMsgCpuServerId;
	    long_ret= CTRL_CPU_Health_Get_cpu_server_id(&ulVar);
	    *var_len = sizeof(ulVar);
	    return (u_char *) & ulVar;

    case CPUHEALTHMSGCPUSERVERFANTHRES:
        *write_method = write_cpuHealthMsgCpuServerFanThres;
        long_ret= CTRL_CPU_Health_Get_cpu_server_fan_thres(&ulVar);
	    *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;

    case CPUHEALTHMSGCPUSERVERFAN:
        *write_method = write_cpuHealthMsgCpuServerFan;
        long_ret= CTRL_CPU_Health_Get_cpu_server_fan(&ulVar);
	    *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;

    case COMPUTERESMSGCPUSERVERID:
        *write_method = write_computeResMsgCpuServerId;
	    long_ret= CTRL_CPU_Cal_Get_cpu_server_id(&ulVar);
	    *var_len = sizeof(ulVar);
	    return (u_char *) & ulVar;

    case COMPUTERESMSGCPUUSGTHRES:
        *write_method = write_computeResMsgCpuUsgThres;
	    long_ret= CTRL_CPU_Cal_Get_cpu_usg_thres(&ulVar);
	    *var_len = sizeof(ulVar);
	    return (u_char *) & ulVar;

    case COMPUTERESMSGCPUUSG:
        *write_method = write_computeResMsgCpuUsg;
	    long_ret= CTRL_CPU_Cal_Get_cpu_usg(&ulVar);
	    *var_len = sizeof(ulVar);
	    return (u_char *) & ulVar;

    case COMPUTERESMSGMEMUSGTHRES:
        *write_method = write_computeResMsgMemUsgThres;
	    long_ret= CTRL_CPU_Cal_Get_mem_usg_thres(&ulVar);
	    *var_len = sizeof(ulVar);
	    return (u_char *) & ulVar;

    case COMPUTERESMSGMEMUSG:
        *write_method = write_computeResMsgMemUsg;
	    long_ret= CTRL_CPU_Cal_Get_mem_usg(&ulVar);
	    *var_len = sizeof(ulVar);
	    return (u_char *) & ulVar;

    default:
        ERROR_MSG("");
    }
    return NULL;
}
/* fpgaAssetMsgTable表索引处理数 */
long header_cpuAssetMsgTable
(
	struct variable *vp,
	oid			 *name,
	size_t 		 *length,
	int			  exact,
	size_t 		 *var_len,
	WriteMethod	**write_method,
	long			 *plIndex
)
{
	long	ret 		= 0;
	long	lComp		= MATCH_FAILED;
	long	lIndex		= 0;
	oid	newname[MAX_OID_LEN];

	memset(newname, 0x00, sizeof(newname));
	memcpy(newname, name, (*length) * sizeof(oid));

	if(exact)	/* get/set	*/
	{
		ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
		if((ret == 0) && (*length == (vp->namelen + 1)))
		{
			lIndex = newname[vp->namelen];
			if((lIndex > 0) && (lIndex <= MAX_CONTRL_DEVICE_CPU_SUM)) lComp = MATCH_SUCCEEDED;
		}
	}
	else		 /* get-next */
	{
		ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);

		if(ret < 0)						 /* name中的OID比注册信息中的OID靠前 */
		{
			memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));
			lComp = MATCH_SUCCEEDED;
			lIndex = 1;
		}
		else if(ret == 0)
		{
		    if(*length == vp->namelen)    /* 没有带索引	*/
			{
				lComp = MATCH_SUCCEEDED;
			    lIndex = 1;
			}
			else if (*length == (vp->namelen + 1)) /* 有参照索引	 */
			{
				lIndex = newname[vp->namelen];
				lIndex += 1;
				if((lIndex > 0) && (lIndex <= MAX_CONTRL_DEVICE_CPU_SUM)) lComp = MATCH_SUCCEEDED;
			}
		}
	}
    if(lComp == MATCH_SUCCEEDED)
    {
		*length  = vp->namelen + 1;
		*plIndex = lIndex;
		newname[vp->namelen] = lIndex;
		memcpy(name, newname, (*length) * sizeof(oid));
	}

	return(lComp);
}


/*
 * var_cpuAssetMsgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_cpuManageMsg above.
 */
unsigned char  *
var_cpuAssetMsgTable(struct variable *vp,
                     oid * name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;
    static long     lIndex;
    static unsigned long ulVar;
    static unsigned char sName[STR_LEN_48];
    static unsigned char sVersion[STR_LEN_16];

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
	if (header_cpuAssetMsgTable(vp,name,length,exact,var_len,write_method, &lIndex)== MATCH_FAILED)
			return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CPUASSETMSGINDEX:
        ulVar= lIndex;
	    *var_len = sizeof(ulVar);
       return ((unsigned char *) & ulVar);
    case CPUASSETMSGCPUNAME:
        *write_method = write_cpuAssetMsgCpuName;
		long_ret= CTRL_CPU_Device_Get_cpu_name((UINT32)lIndex,(char*)sName,STR_LEN_48);
	    *var_len = STR_LEN_48;
        return (u_char *)sName;
    case CPUASSETMSGBIOSVERSION:
        *write_method = write_cpuAssetMsgBiosVersion;
		long_ret= CTRL_CPU_Device_Get_cpu_name(lIndex,sVersion,STR_LEN_16);
	    *var_len = STR_LEN_16;
        return (u_char *)sVersion;
    case CPUASSETMSGROWSTATUS:
        *write_method = write_cpuAssetMsgRowStatus;
        return lIndex;
    default:
        ERROR_MSG("");
    }
    return NULL;
}
long header_cpuHealthMsgTable
(
	struct variable *vp,
	oid			 *name,
	size_t 		 *length,
	int			  exact,
	size_t 		 *var_len,
	WriteMethod	**write_method,
	long			 *plIndex
)
{
	long	ret 		= 0;
	long	lComp		= MATCH_FAILED;
	long	lIndex		= 0;
	oid	newname[MAX_OID_LEN];

	memset(newname, 0x00, sizeof(newname));
	memcpy(newname, name, (*length) * sizeof(oid));

	if(exact)	/* get/set	*/
	{
		ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
		if((ret == 0) && (*length == (vp->namelen + 1)))
		{
			lIndex = newname[vp->namelen];
			if((lIndex > 0) && (lIndex <= MAX_CONTRL_DEVICE_CPU_SUM)) lComp = MATCH_SUCCEEDED;
		}
	}
	else		 /* get-next */
	{
		ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);

		if(ret < 0)						 /* name中的OID比注册信息中的OID靠前 */
		{
			memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));
			lComp = MATCH_SUCCEEDED;
			lIndex = 1;
		}
		else if(ret == 0)
		{
		    if(*length == vp->namelen)    /* 没有带索引	*/
			{
				lComp = MATCH_SUCCEEDED;
			    lIndex = 1;
			}
			else if (*length == (vp->namelen + 1)) /* 有参照索引	 */
			{
				lIndex = newname[vp->namelen];
				lIndex += 1;
				if((lIndex > 0) && (lIndex <= MAX_CONTRL_DEVICE_CPU_SUM)) lComp = MATCH_SUCCEEDED;
			}
		}
	}
	if(lComp == MATCH_SUCCEEDED)
	{
		*length  = vp->namelen + 1;
		*plIndex = lIndex;
		newname[vp->namelen] = lIndex;
		memcpy(name, newname, (*length) * sizeof(oid));
	}

    return(lComp);
}
/*
 * var_cpuHealthMsgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_cpuManageMsg above.
 */
unsigned char  *
var_cpuHealthMsgTable(struct variable *vp,
                      oid * name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;
    static long     lIndex;
    static unsigned long ulVar;
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
	if (header_cpuAssetMsgTable(vp,name,length,exact,var_len,write_method, &lIndex)== MATCH_FAILED)
			return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CPUHEALTHMSGINDEX:
        ulVar= lIndex;
	    *var_len = sizeof(ulVar);
       return ((unsigned char *) & ulVar);
    case CPUHEALTHMSGCPUID:
        *write_method = write_cpuHealthMsgCpuId;
		long_ret = CTRL_CPU_HealthInfo_Get_cpu_id(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;
    case CPUHEALTHMSGTEMPTHRES:
        *write_method = write_cpuHealthMsgTempThres;
		long_ret = CTRL_CPU_HealthInfo_Get_cpu_temp_thres(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;
    case CPUHEALTHMSGTEMP:
        *write_method = write_cpuHealthMsgTemp;
		long_ret = CTRL_CPU_HealthInfo_Get_cpu_temp(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;
    case CPUHEALTHMSGVOLTHRES:
        *write_method = write_cpuHealthMsgVolThres;
		long_ret = CTRL_CPU_HealthInfo_Get_cpu_vol_thres(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;
    case CPUHEALTHMSGVOL:
        *write_method = write_cpuHealthMsgVol;
		long_ret = CTRL_CPU_HealthInfo_Get_cpu_vol(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;
    case CPUHEALTHMSGROWSTATUS:
        *write_method = write_cpuHealthMsgRowStatus;
        ulVar = lIndex;
        return (u_char *) & ulVar;
    default:
        ERROR_MSG("");
    }
    return NULL;
}



int
write_cpuAssetMsgCpuServerId(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_cpuAssetMsgBmcId(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_cpuAssetMsgBmcName(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to cpuManageMsg not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_cpuAssetMsgBmcFwVersion(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to cpuManageMsg not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_cpuAssetMsgBmcAddr(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to cpuManageMsg not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_cpuHealthMsgCpuServerId(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_cpuHealthMsgCpuServerFanThres(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    u_long          value;
    CpuServerFanThresConf cpuServerFanTresConf;
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
    	cpuServerFanTresConf.msghead.msg_type = MODULE_CFIG_MGMT;
    	cpuServerFanTresConf.msghead.msg_code = CFG_MGMT_BORD_MGMT_CPU_FAN_THRES_CFG_REQ;
    	cpuServerFanTresConf.msghead.msg_len = sizeof(CpuServerFanThresConf);
    	cpuServerFanTresConf.cpu_server_fan_thres = *(u_long *) var_val;
        if (send_msg_to_om(MODULE_BORD_MGMT,(char*)&cpuServerFanTresConf,sizeof(CpuServerFanThresConf)) != 0)
        {
        	return SNMP_ERR_COMMITFAILED;
        }
//        send_msg_to_om(MODULE_BORD_MGMT,(char*)&cpuServerFanTresConf,sizeof(CpuServerFanThresConf));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_cpuHealthMsgCpuServerFan(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_computeResMsgCpuServerId(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_computeResMsgCpuUsgThres(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    float          value;
    int             size;
    CpuUsgThresConf cpuUsgTresConf;
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(float *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
//		if(CTRL_CPU_Cal_Set_cpu_usg_thres(&value)!=SUCCESS)
//		{
//		    return SNMP_ERR_WRONGTYPE;
//		}
    	cpuUsgTresConf.msghead.msg_type = MODULE_CFIG_MGMT;
    	cpuUsgTresConf.msghead.msg_code = CFG_MGMT_BORD_MGMT_CPU_USG_THRES_CFG_REQ;
    	cpuUsgTresConf.msghead.msg_len = sizeof(CpuUsgThresConf);
    	cpuUsgTresConf.cpu_usg_thres = *(float *) var_val;
        if (send_msg_to_om(MODULE_BORD_MGMT,(char*)&cpuUsgTresConf,sizeof(CpuUsgThresConf)) != 0)
        {
        	return SNMP_ERR_COMMITFAILED;
        }
//        send_msg_to_om(MODULE_BORD_MGMT,(char*)&cpuUsgTresConf,sizeof(CpuUsgThresConf));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_computeResMsgCpuUsg(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_computeResMsgMemUsgThres(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    float          value;
    int             size;
    MemUsgThresConf memUsgThresConf;
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(float *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
//		if(CTRL_CPU_Cal_Set_mem_usg_thres(&value)!=SUCCESS)
//		{
//		    return SNMP_ERR_WRONGTYPE;
//		}
    	memUsgThresConf.msghead.msg_type = MODULE_CFIG_MGMT;
    	memUsgThresConf.msghead.msg_code = CFG_MGMT_BORD_MGMT_MEM_USG_THRES_CFG_REQ;
    	memUsgThresConf.msghead.msg_len = sizeof(MemUsgThresConf);
    	memUsgThresConf.mem_usg_thres = *(float *) var_val;
        if (send_msg_to_om(MODULE_BORD_MGMT,(char*)&memUsgThresConf,sizeof(MemUsgThresConf)) != 0)
        {
        	return SNMP_ERR_COMMITFAILED;
        }
//        send_msg_to_om(MODULE_BORD_MGMT,(char*)&memUsgThresConf,sizeof(MemUsgThresConf));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_computeResMsgMemUsg(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cpuAssetMsgCpuName(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to cpuManageMsg not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cpuAssetMsgBiosVersion(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to cpuManageMsg not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cpuAssetMsgRowStatus(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cpuManageMsg not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cpuHealthMsgCpuId(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cpuHealthMsgTempThres(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	unsigned long   ulIndex;
	CpuTempThresConf cpuTempThresConf;
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
	    ulIndex = name[CPUMANAGE_INDEX_POS];
//		if(CTRL_CPU_HealthInfo_Set_cpu_temp_thres(ulIndex,&value)!=SUCCESS)
//		{
//		    return SNMP_ERR_WRONGTYPE;
//		}
	    cpuTempThresConf.msghead.msg_type = MODULE_CFIG_MGMT;
	    cpuTempThresConf.msghead.msg_code = CFG_MGMT_BORD_MGMT_CPU_TEMP_THRES_CFG_REQ;
	    cpuTempThresConf.msghead.msg_len = sizeof(CpuTempThresConf);
	    cpuTempThresConf.cpu_index= ulIndex;
	    cpuTempThresConf.cpu_temp_thres= *(u_long *) var_val;
        if (send_msg_to_om(MODULE_BORD_MGMT,(char*)&cpuTempThresConf,sizeof(CpuTempThresConf)) != 0)
        {
        	return SNMP_ERR_COMMITFAILED;
        }
//        send_msg_to_om(MODULE_BORD_MGMT,(char*)&cpuTempThresConf,sizeof(CpuTempThresConf));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cpuHealthMsgTemp(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cpuHealthMsgVolThres(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    unsigned long   ulIndex;
    CpuVolThresConf cpuVolThresConf;
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
	    ulIndex = name[CPUMANAGE_INDEX_POS];
//		if(CTRL_CPU_HealthInfo_Set_cpu_vol_thres(ulIndex,&value)!=SUCCESS)
//		{
//		    return SNMP_ERR_WRONGTYPE;
//		}
	    cpuVolThresConf.msghead.msg_type = MODULE_CFIG_MGMT;
	    cpuVolThresConf.msghead.msg_code = CFG_MGMT_BORD_MGMT_CPU_VOL_THRES_CFG_REQ;
	    cpuVolThresConf.msghead.msg_len = sizeof(CpuVolThresConf);
	    cpuVolThresConf.cpu_index= ulIndex;
	    cpuVolThresConf.cpu_vol_thres = *(u_long *) var_val;
        if (send_msg_to_om(MODULE_BORD_MGMT,(char*)&cpuVolThresConf,sizeof(CpuVolThresConf)) != 0)
        {
        	return SNMP_ERR_COMMITFAILED;
        }
//        send_msg_to_om(MODULE_BORD_MGMT,(char*)&cpuVolThresConf,sizeof(CpuVolThresConf));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cpuHealthMsgVol(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to cpuManageMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cpuHealthMsgRowStatus(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to cpuManageMsg not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to cpuManageMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

