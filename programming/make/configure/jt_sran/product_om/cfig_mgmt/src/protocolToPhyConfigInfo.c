/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:33 CST. */
/* 
 Copyright (C) Rong Tao @Beijing

 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.3
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
 Texts. A copy of the license is included in the section entitled ‘‘GNU
 Free Documentation License’’.
   2019年 03月 14日 星期四 19:24:45 CST. 
*/
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 08日 星期五 08:10:29 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:28:04 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "protocolToPhyConfigInfo.h"
#define SCALAR_SET_ACTION_INTEGER(node,leaf)    \
  node.old_##leaf = node.leaf;                  \
  node.leaf = *requests->requestvb->val.integer

#define SCALAR_SET_UNDO_INTEGER(node,leaf)      \
  node.leaf = node.old_##leaf;                  \
  node.old_##leaf = 0
/** Initializes the protocolToPhyConfigInfo module */
sbs_protocolToPhyConfigInfo_Scalar_t proTophy_scalar_packet;
char proTophy_info_int_value[8];
void
init_protocolToPhyConfigInfo(void)
{
    const oid       protocolToPhyConfigInfophyCfg_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 1 };
    const oid       protocolToPhyConfigInfopuschDtxThresh_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 2 };
    const oid       protocolToPhyConfigInfomuxPuschANDT_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 3 };
    const oid       protocolToPhyConfigInfomuxPuschCDT_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 4 };
    const oid       protocolToPhyConfigInfomuxPuschRDT_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 5 };
    const oid       protocolToPhyConfigInfopucchRbStart_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 6 };
    const oid       protocolToPhyConfigInfopucchF1DT_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 7 };
    const oid       protocolToPhyConfigInfopucchF2DT_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 8 };
    const oid       protocolToPhyConfigInfoprachThresh_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 9 };
    const oid       protocolToPhyConfigInforadioAccessMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 10 };
    const oid       protocolToPhyConfigInfopsyncPower_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 11 };
    const oid       protocolToPhyConfigInfossyncPower_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 12 };
    const oid       protocolToPhyConfigInfoimcs_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 13 };
    const oid       protocolToPhyConfigInfomumimo_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 14 };
    const oid       protocolToPhyConfigInfosyncantselection_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 15 };
    const oid       protocolToPhyConfigInfocarrierAggrLev_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 16 };
    const oid       protocolToPhyConfigInfooperationalMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 5, 17 };

    DEBUGMSGTL(("protocolToPhyConfigInfo", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfophyCfg",
                             handle_protocolToPhyConfigInfophyCfg,
                             protocolToPhyConfigInfophyCfg_oid,
                             OID_LENGTH(protocolToPhyConfigInfophyCfg_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfopuschDtxThresh",
                             handle_protocolToPhyConfigInfopuschDtxThresh,
                             protocolToPhyConfigInfopuschDtxThresh_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfopuschDtxThresh_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfomuxPuschANDT",
                             handle_protocolToPhyConfigInfomuxPuschANDT,
                             protocolToPhyConfigInfomuxPuschANDT_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfomuxPuschANDT_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfomuxPuschCDT",
                             handle_protocolToPhyConfigInfomuxPuschCDT,
                             protocolToPhyConfigInfomuxPuschCDT_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfomuxPuschCDT_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfomuxPuschRDT",
                             handle_protocolToPhyConfigInfomuxPuschRDT,
                             protocolToPhyConfigInfomuxPuschRDT_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfomuxPuschRDT_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfopucchRbStart",
                             handle_protocolToPhyConfigInfopucchRbStart,
                             protocolToPhyConfigInfopucchRbStart_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfopucchRbStart_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfopucchF1DT",
                             handle_protocolToPhyConfigInfopucchF1DT,
                             protocolToPhyConfigInfopucchF1DT_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfopucchF1DT_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfopucchF2DT",
                             handle_protocolToPhyConfigInfopucchF2DT,
                             protocolToPhyConfigInfopucchF2DT_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfopucchF2DT_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfoprachThresh",
                             handle_protocolToPhyConfigInfoprachThresh,
                             protocolToPhyConfigInfoprachThresh_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfoprachThresh_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInforadioAccessMode",
                             handle_protocolToPhyConfigInforadioAccessMode,
                             protocolToPhyConfigInforadioAccessMode_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInforadioAccessMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfopsyncPower",
                             handle_protocolToPhyConfigInfopsyncPower,
                             protocolToPhyConfigInfopsyncPower_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfopsyncPower_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfossyncPower",
                             handle_protocolToPhyConfigInfossyncPower,
                             protocolToPhyConfigInfossyncPower_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfossyncPower_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfoimcs",
                             handle_protocolToPhyConfigInfoimcs,
                             protocolToPhyConfigInfoimcs_oid,
                             OID_LENGTH(protocolToPhyConfigInfoimcs_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfomumimo",
                             handle_protocolToPhyConfigInfomumimo,
                             protocolToPhyConfigInfomumimo_oid,
                             OID_LENGTH(protocolToPhyConfigInfomumimo_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfosyncantselection",
                             handle_protocolToPhyConfigInfosyncantselection,
                             protocolToPhyConfigInfosyncantselection_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfosyncantselection_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfocarrierAggrLev",
                             handle_protocolToPhyConfigInfocarrierAggrLev,
                             protocolToPhyConfigInfocarrierAggrLev_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfocarrierAggrLev_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("protocolToPhyConfigInfooperationalMode",
                             handle_protocolToPhyConfigInfooperationalMode,
                             protocolToPhyConfigInfooperationalMode_oid,
                             OID_LENGTH
                             (protocolToPhyConfigInfooperationalMode_oid),
                             HANDLER_CAN_RWRITE));
}

int
handle_protocolToPhyConfigInfophyCfg(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */  (void*)&(proTophy_scalar_packet.protocolToPhyConfigInfophyCfg),
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfophyCfg));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:


    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
    	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfophyCfg);
        //write xml file
    	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
    	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
    	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_phyCfg, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
        break;

    case MODE_SET_COMMIT:

        break;

    case MODE_SET_UNDO:

   	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfophyCfg);

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfophyCfg\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfopuschDtxThresh(netsnmp_mib_handler *handler,
                                             netsnmp_handler_registration
                                             *reginfo,
                                             netsnmp_agent_request_info
                                             *reqinfo,
                                             netsnmp_request_info
                                             *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfopuschDtxThresh),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfopuschDtxThresh));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:


    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopuschDtxThresh);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_puschDtxThresh, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopuschDtxThresh);

            break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfopuschDtxThresh\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfomuxPuschANDT(netsnmp_mib_handler *handler,
                                           netsnmp_handler_registration
                                           *reginfo,
                                           netsnmp_agent_request_info
                                           *reqinfo,
                                           netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfomuxPuschANDT),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfomuxPuschANDT));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfomuxPuschANDT);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_muxPuschAckNackDetThresh, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfomuxPuschANDT);

            break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfomuxPuschANDT\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfomuxPuschCDT(netsnmp_mib_handler *handler,
                                          netsnmp_handler_registration
                                          *reginfo,
                                          netsnmp_agent_request_info
                                          *reqinfo,
                                          netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfomuxPuschCDT),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfomuxPuschCDT));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:


    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;


    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfomuxPuschCDT);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_muxPuschCqiDetThresh, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfomuxPuschCDT);

            break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfomuxPuschCDT\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfomuxPuschRDT(netsnmp_mib_handler *handler,
                                          netsnmp_handler_registration
                                          *reginfo,
                                          netsnmp_agent_request_info
                                          *reqinfo,
                                          netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfomuxPuschRDT),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfomuxPuschRDT));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfomuxPuschRDT);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_muxPuschRiDetThresh, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfomuxPuschRDT);

            break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfomuxPuschRDT\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfopucchRbStart(netsnmp_mib_handler *handler,
                                           netsnmp_handler_registration
                                           *reginfo,
                                           netsnmp_agent_request_info
                                           *reqinfo,
                                           netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */ (void*)&(proTophy_scalar_packet.protocolToPhyConfigInfopucchRbStart),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfopucchRbStart));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopucchRbStart);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_pucchRbStart, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopucchRbStart);

            break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfopucchRbStart\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfopucchF1DT(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfopucchF1DT),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfopucchF1DT));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopucchF1DT);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_pucchF1DetThresh, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopucchF1DT);

            break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfopucchF1DT\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfopucchF2DT(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfopucchF2DT),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfopucchF2DT));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopucchF2DT);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_pucchF2sDetThresh, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopucchF2DT);

            break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfopucchF2DT\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfoprachThresh(netsnmp_mib_handler *handler,
                                          netsnmp_handler_registration
                                          *reginfo,
                                          netsnmp_agent_request_info
                                          *reqinfo,
                                          netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfoprachThresh),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfoprachThresh));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfoprachThresh);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_prachThresh, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfoprachThresh);

            break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfoprachThresh\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInforadioAccessMode(netsnmp_mib_handler *handler,
                                              netsnmp_handler_registration
                                              *reginfo,
                                              netsnmp_agent_request_info
                                              *reqinfo,
                                              netsnmp_request_info
                                              *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInforadioAccessMode),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInforadioAccessMode));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
    	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
    	memcpy(proTophy_scalar_packet.protocolToPhyConfigInforadioAccessMode, requests->requestvb->val.string,
				requests->requestvb->val_len);
    	memcpy(proTophy_info_int_value,
    			requests->requestvb->val.string,
				requests->requestvb->val_len);
        //write xml file
    	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_radioAccessMode, proTophy_info_int_value,OPERATE_MODIFY_NAME);
        break;

    case MODE_SET_COMMIT:

        break;

    case MODE_SET_UNDO:

    	memcpy(proTophy_scalar_packet.protocolToPhyConfigInforadioAccessMode, proTophy_scalar_packet.old_protocolToPhyConfigInforadioAccessMode,
				8);

        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInforadioAccessMode\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfopsyncPower(netsnmp_mib_handler *handler,
                                         netsnmp_handler_registration
                                         *reginfo,
                                         netsnmp_agent_request_info
                                         *reqinfo,
                                         netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfopsyncPower),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfopsyncPower));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopsyncPower);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_psyncPower, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfopsyncPower);

            break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfopsyncPower\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfossyncPower(netsnmp_mib_handler *handler,
                                         netsnmp_handler_registration
                                         *reginfo,
                                         netsnmp_agent_request_info
                                         *reqinfo,
                                         netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfossyncPower),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfossyncPower));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfossyncPower);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_ssyncPower, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfossyncPower);

            break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfossyncPower\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfoimcs(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfoimcs),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfoimcs));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfoimcs);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_imcs, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfoimcs);

            break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfoimcs\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfomumimo(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfomumimo),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfomumimo));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
    	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
    	memcpy(proTophy_scalar_packet.protocolToPhyConfigInfomumimo, requests->requestvb->val.string,
				requests->requestvb->val_len);
    	memcpy(proTophy_info_int_value,
    			requests->requestvb->val.string,
				requests->requestvb->val_len);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_mu_mimo, proTophy_info_int_value,OPERATE_MODIFY_NAME);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

        	memcpy(proTophy_scalar_packet.protocolToPhyConfigInfomumimo, proTophy_scalar_packet.old_protocolToPhyConfigInfomumimo,
        					8);

            break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfomumimo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfosyncantselection(netsnmp_mib_handler
                                               *handler,
                                               netsnmp_handler_registration
                                               *reginfo,
                                               netsnmp_agent_request_info
                                               *reqinfo,
                                               netsnmp_request_info
                                               *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfosyncantselection),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfosyncantselection));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
    	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
    	memcpy(proTophy_scalar_packet.protocolToPhyConfigInfosyncantselection, requests->requestvb->val.string,
				requests->requestvb->val_len);
    	memcpy(proTophy_info_int_value,
    			requests->requestvb->val.string,
				requests->requestvb->val_len);
        //write xml file
    	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_sync_ant_selection, proTophy_info_int_value,OPERATE_MODIFY_NAME);
        break;

    case MODE_SET_COMMIT:

        break;

    case MODE_SET_UNDO:

    	memcpy(proTophy_scalar_packet.protocolToPhyConfigInfosyncantselection, proTophy_scalar_packet.old_protocolToPhyConfigInfosyncantselection,
    					8);

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfosyncantselection\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfocarrierAggrLev(netsnmp_mib_handler *handler,
                                             netsnmp_handler_registration
                                             *reginfo,
                                             netsnmp_agent_request_info
                                             *reqinfo,
                                             netsnmp_request_info
                                             *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfocarrierAggrLev),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfocarrierAggrLev));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        	SCALAR_SET_ACTION_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfocarrierAggrLev);
            //write xml file
        	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
        	sprintf(proTophy_info_int_value, "%d",*requests->requestvb->val.integer);
        	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_carrier_aggregation_leve, proTophy_info_int_value,OPERATE_MODIFY_VALUE);
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

       	    SCALAR_SET_UNDO_INTEGER(proTophy_scalar_packet, protocolToPhyConfigInfocarrierAggrLev);


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfocarrierAggrLev\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_protocolToPhyConfigInfooperationalMode(netsnmp_mib_handler *handler,
                                              netsnmp_handler_registration
                                              *reginfo,
                                              netsnmp_agent_request_info
                                              *reqinfo,
                                              netsnmp_request_info
                                              *requests)
{
    int             ret;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 /*
                                  * XXX: a pointer to the scalar's data 
                                  */(void*)&(proTophy_scalar_packet.protocolToPhyConfigInfooperationalMode),
	                                 /*
	                                  * XXX: the length of the data in bytes
	                                  */ sizeof(proTophy_scalar_packet.protocolToPhyConfigInfooperationalMode));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
    	memset(proTophy_info_int_value,0,sizeof(proTophy_info_int_value));
    	memcpy(proTophy_scalar_packet.protocolToPhyConfigInfooperationalMode, requests->requestvb->val.string,
				requests->requestvb->val_len);
    	memcpy(proTophy_info_int_value,
    			requests->requestvb->val.string,
				requests->requestvb->val_len);
        //write xml file
    	ret = modify_proTophycfg_file( PROTOCOL_TO_PHY_CFG_DEFAULT, proTophyCfg_operational_mode, proTophy_info_int_value,OPERATE_MODIFY_NAME);
        break;

    case MODE_SET_COMMIT:

        break;

    case MODE_SET_UNDO:

    	memcpy(proTophy_scalar_packet.protocolToPhyConfigInfooperationalMode, proTophy_scalar_packet.old_protocolToPhyConfigInfooperationalMode,
				8);

        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_protocolToPhyConfigInfooperationalMode\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
