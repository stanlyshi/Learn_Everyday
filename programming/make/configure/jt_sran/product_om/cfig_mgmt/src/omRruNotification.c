/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:33 CST. */
/* 
 Copyright (C) Rong Tao @Beijing

 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.3
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
 Texts. A copy of the license is included in the section entitled ‘‘GNU
 Free Documentation License’’.
   2019年 03月 14日 星期四 19:24:45 CST. 
*/
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 08日 星期五 08:10:29 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:28:04 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "omRruNotification.h"

extern const oid snmptrap_oid[];
extern const size_t snmptrap_oid_len;

int
send_rruInitResp_trap(ICR_RRU_INIT_RESULT_TRAP *msg)
{
    netsnmp_variable_list *var_list = NULL;
    const oid       rruInitResp_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 4, 4, 2, 1 };
    const oid       rruTrapRruId_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 1, 1, 1, 2, msg->rru_id};
    const oid       rruTrapRruSn_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 1, 1, 1, 3, msg->rru_id};

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
                              snmptrap_oid, snmptrap_oid_len,
                              ASN_OBJECT_ID,
                              rruInitResp_oid, sizeof(rruInitResp_oid));

    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
                              rruTrapRruId_oid,
                              OID_LENGTH(rruTrapRruId_oid), ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for rruTrapRruId 
                               */
                              &msg->rru_id, sizeof(msg->rru_id));
    snmp_varlist_add_variable(&var_list,
                              rruTrapRruSn_oid,
                              OID_LENGTH(rruTrapRruSn_oid), ASN_OCTET_STR,
                              /*
                               * Set an appropriate value for rruTrapRruSn 
                               */
                              msg->serial_no, strlen(msg->serial_no));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap(var_list);
    snmp_free_varbind(var_list);

    return SNMP_ERR_NOERROR;
}

int
send_rruRingTestResp_trap(ICR_RRU_RING_TEST_RESULT *msg)
{
    netsnmp_variable_list *var_list = NULL;
    const oid       rruRingTestResp_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 4, 4, 2, 2 };
    const oid       rruTrapPortNo_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 1, 1, 1, 4, msg->rru_id};
    const oid       rruTrapResult_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 1, 1, 1, 5, msg->rru_id};

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
                              snmptrap_oid, snmptrap_oid_len,
                              ASN_OBJECT_ID,
                              rruRingTestResp_oid,
                              sizeof(rruRingTestResp_oid));

    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
                              rruTrapPortNo_oid,
                              OID_LENGTH(rruTrapPortNo_oid), ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for rruTrapPortNo 
                               */
                              &msg->port_no, sizeof(msg->port_no));
    snmp_varlist_add_variable(&var_list,
                              rruTrapResult_oid,
                              OID_LENGTH(rruTrapResult_oid), ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for rruTrapResult 
                               */
                              &msg->result, sizeof(msg->result));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap(var_list);
    snmp_free_varbind(var_list);

    return SNMP_ERR_NOERROR;
}

#if 0
int
send_rruResetResp_trap(void)
{
    netsnmp_variable_list *var_list = NULL;
    const oid       rruResetResp_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 4, 4, 2, 3 };
    const oid       rruTrapResult_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 1, 1, 1, 5,
/* insert index here */  };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
                              snmptrap_oid, snmptrap_oid_len,
                              ASN_OBJECT_ID,
                              rruResetResp_oid, sizeof(rruResetResp_oid));

    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
                              rruTrapResult_oid,
                              OID_LENGTH(rruTrapResult_oid), ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for rruTrapResult 
                               */
                              NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap(var_list);
    snmp_free_varbind(var_list);

    return SNMP_ERR_NOERROR;
}
#endif

int
send_rruSwUpdateResp_trap(ICR_RRU_SW_UPDATE_RESULT *msg)
{
    netsnmp_variable_list *var_list = NULL;
    const oid       rruSwUpdateResp_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 4, 4, 2, 4 };
    const oid       rruTrapVerUpdate_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 1, 1, 1, 6, msg->rru_id};
    const oid       rruTrapErrType_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 1, 1, 1, 7, msg->rru_id};

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
                              snmptrap_oid, snmptrap_oid_len,
                              ASN_OBJECT_ID,
                              rruSwUpdateResp_oid,
                              sizeof(rruSwUpdateResp_oid));

    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
                              rruTrapVerUpdate_oid,
                              OID_LENGTH(rruTrapVerUpdate_oid),
                              ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for rruTrapVerUpdate 
                               */
                              &msg->VerUpdate, sizeof(msg->VerUpdate));
    snmp_varlist_add_variable(&var_list,
                              rruTrapErrType_oid,
                              OID_LENGTH(rruTrapErrType_oid), ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for rruTrapErrType 
                               */
                              &msg->ErrType, sizeof(msg->ErrType));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap(var_list);
    snmp_free_varbind(var_list);

    return SNMP_ERR_NOERROR;
}

int
send_cpriRingTestResp_trap(ICR_CPRI_RING_TEST_RESULT *msg)
{
    netsnmp_variable_list *var_list = NULL;
    const oid       cpriRingTestResp_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 4, 4, 3, 1 };
    const oid       cpriTrapResult_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 2, 1, 1, 2, msg->cpri_index};

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
                              snmptrap_oid, snmptrap_oid_len,
                              ASN_OBJECT_ID,
                              cpriRingTestResp_oid,
                              sizeof(cpriRingTestResp_oid));

    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
                              cpriTrapResult_oid,
                              OID_LENGTH(cpriTrapResult_oid), ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for cpriTrapResult 
                               */
                              &msg->result, sizeof(msg->result));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap(var_list);
    snmp_free_varbind(var_list);

    return SNMP_ERR_NOERROR;
}

int
send_cpriErrTestResp_trap(ICR_CPRI_SER_TEST_RESULT *msg)
{
    netsnmp_variable_list *var_list = NULL;
    const oid       cpriErrTestResp_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 4, 4, 3, 2 };
    const oid       cpriTrapResult_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 2, 1, 1, 2, msg->cpri_index};

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
                              snmptrap_oid, snmptrap_oid_len,
                              ASN_OBJECT_ID,
                              cpriErrTestResp_oid,
                              sizeof(cpriErrTestResp_oid));

    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
                              cpriTrapResult_oid,
                              OID_LENGTH(cpriTrapResult_oid), ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for cpriTrapResult 
                               */
                              &msg->result, sizeof(msg->result));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap(var_list);
    snmp_free_varbind(var_list);

    return SNMP_ERR_NOERROR;
}

int
send_cpriDelayCfgResp_trap(ICR_CPRI_TIME_DELAY_CFG_RESULT *msg)
{
    netsnmp_variable_list *var_list = NULL;
    const oid       cpriDelayCfgResp_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 4, 4, 3, 3 };
    const oid       cpriTrapResult_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 2, 1, 1, 2, msg->cpri_index};

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
                              snmptrap_oid, snmptrap_oid_len,
                              ASN_OBJECT_ID,
                              cpriDelayCfgResp_oid,
                              sizeof(cpriDelayCfgResp_oid));

    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
                              cpriTrapResult_oid,
                              OID_LENGTH(cpriTrapResult_oid), ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for cpriTrapResult 
                               */
                              &msg->result, sizeof(msg->result));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap(var_list);
    snmp_free_varbind(var_list);

    return SNMP_ERR_NOERROR;
}

int
send_cpriSingleCfgResp_trap(ICR_SINGLE_SEND_RESULT *msg)
{
    netsnmp_variable_list *var_list = NULL;
    const oid       cpriSingleCfgResp_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 4, 4, 3, 4 };
    const oid       cpriTrapResult_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 2, 3, 2, 1, 1, 2, msg->cpri_index};

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
                              snmptrap_oid, snmptrap_oid_len,
                              ASN_OBJECT_ID,
                              cpriSingleCfgResp_oid,
                              sizeof(cpriSingleCfgResp_oid));

    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
                              cpriTrapResult_oid,
                              OID_LENGTH(cpriTrapResult_oid), ASN_UNSIGNED,
                              /*
                               * Set an appropriate value for cpriTrapResult 
                               */
                              &msg->result, sizeof(msg->result));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap(var_list);
    snmp_free_varbind(var_list);

    return SNMP_ERR_NOERROR;
}

INT32 handle_fn_rru_trap_msg(void* buf, UINT32 msg_len){
	switch(((CommMsgHead*)buf)->msg_code){
		case TRAP_RRU_INIT_RESULT:
			if(msg_len != sizeof(ICR_RRU_INIT_RESULT_TRAP)){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			if(send_rruInitResp_trap((ICR_RRU_INIT_RESULT_TRAP*)buf) != 0){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			break;
			
		case TRAP_CPRI_RING_TEST:
			if(msg_len != sizeof(ICR_CPRI_RING_TEST_RESULT)){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			if(send_rruRingTestResp_trap((ICR_CPRI_RING_TEST_RESULT*)buf) != 0){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			break;
			
		case TRAP_CPRI_SER_TEST:
			if(msg_len != sizeof(ICR_CPRI_SER_TEST_RESULT)){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			if(send_rruRingTestResp_trap((ICR_CPRI_SER_TEST_RESULT*)buf) != 0){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			break;
			
		case TRAP_CPRI_TIME_DELAY_CFG:
			if(msg_len != sizeof(ICR_CPRI_TIME_DELAY_CFG_RESULT)){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			if(send_rruRingTestResp_trap((ICR_CPRI_TIME_DELAY_CFG_RESULT*)buf) != 0){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			break;
		case TRAP_SINGLE_SEND_RESULT:
			if(msg_len != sizeof(ICR_SINGLE_SEND_RESULT)){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			if(send_rruRingTestResp_trap((ICR_SINGLE_SEND_RESULT*)buf) != 0){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			break;
		case TRAP_RRU_RING_TEST:
			if(msg_len != sizeof(ICR_RRU_RING_TEST_RESULT)){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			if(send_rruRingTestResp_trap((ICR_RRU_RING_TEST_RESULT*)buf) != 0){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			break;
		case TRAP_RRU_SOFTWARE_UPDATE:
			if(msg_len != sizeof(ICR_RRU_SW_UPDATE_RESULT)){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			if(send_rruRingTestResp_trap((ICR_RRU_SW_UPDATE_RESULT*)buf) != 0){
				log_msg(LOG_WARNING, MAIN, "recv msgq's length is invalid\n");
				return -1;
			}
			break;
		default:
			log_msg(LOG_WARNING, MAIN, "wrong msgcode in handle rru trap\n");
	}
	
	return 0;
}

