/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:33 CST. */
/* 
 Copyright (C) Rong Tao @Beijing

 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.3
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
 Texts. A copy of the license is included in the section entitled ‘‘GNU
 Free Documentation License’’.
   2019年 03月 14日 星期四 19:24:45 CST. 
*/
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 08日 星期五 08:10:29 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:28:04 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rruInitInfo.h"


/*
 * rruInitInfo_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

void charVec2intVec(int * int_vec, char *char_vec, int len)
{
	int i = 0;
	while(i < len){
		int_vec[i] = char_vec[i] - '0';	
		i++;
	}
}

oid             rruInitInfo_variables_oid[] =
    { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 3, 1 };

/*
 * variable4 rruInitInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the rruInitInfo mib section 
 */

struct variable4 rruInitInfo_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */

#define RRUINITMSGINDEX		1
    {RRUINITMSGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_rruInitMsgTable, 3, {1, 1, 1}},
#define RRUINITMSGRRUID		2
    {RRUINITMSGRRUID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 2}},
#define RRUINITMSGSERIALNO		3
    {RRUINITMSGSERIALNO, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 3}},
#define RRUINITMSGPERIOD		4
    {RRUINITMSGPERIOD, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 4}},
#define RRUINITMSGVSWRTHRES1		5
    {RRUINITMSGVSWRTHRES1, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 5}},
#define RRUINITMSGVSWRTHRES2		6
    {RRUINITMSGVSWRTHRES2, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 6}},
#define RRUINITMSGUPTHRES		7
    {RRUINITMSGUPTHRES, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 7}},
#define RRUINITMSGLOWTHRES		8
    {RRUINITMSGLOWTHRES, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 8}},
#define RRUINITMSGANTMODE		9
    {RRUINITMSGANTMODE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 9}},
#define RRUINITMSGANTSETNO		10
    {RRUINITMSGANTSETNO, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 10}},
#define RRUINITMSGANTSTATE		11
    {RRUINITMSGANTSTATE, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 11}},
#define RRUINITMSGUPPATHSTATE		12
    {RRUINITMSGUPPATHSTATE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 12}},
#define RRUINITMSGDWPATHSTATE		13
    {RRUINITMSGDWPATHSTATE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 13}},
#define RRUINITMSGROWSTATUS		14
    {RRUINITMSGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_rruInitMsgTable, 3, {1, 1, 14}},
};

/*
 * (L = length of the oidsuffix) 
 */
 
static rruInitMsgTable rruInitMsgTable_RowBuf;

/** Initializes the rruInitInfo module */
void
init_rruInitInfo(void)
{

    DEBUGMSGTL(("rruInitInfo", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("rruInitInfo", rruInitInfo_variables, variable4,
                 rruInitInfo_variables_oid);

    /*
     * place any other initialization junk you need here 
     */
     
}

/*
 * var_rruInitInfo():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_rruInitInfo(struct variable *vp,
                oid * name,
                size_t *length,
                int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        ERROR_MSG("");
    }
    return NULL;
}

UINT32 header_rruInitMsgTable
(
	struct variable *vp,
	oid 			*name,
	size_t			*length,
	int 			 exact,
	size_t			*var_len,
	WriteMethod    **write_method,
	long			*plIndex
)
{
	UINT32 ret = 0;
	UINT32 lComp =  MATCH_FAILED; 
	UINT32 lIndex = 0;
	oid newname[MAX_OID_LEN];

	memset(newname, 0x00, sizeof(newname));
    memcpy(newname, name, (*length) * sizeof(oid));

	if(exact)  /* get/set  */
    {
        ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
        if((ret == 0) && (*length == (vp->namelen + 1)))
		{
	        lIndex = newname[vp->namelen];
		    if((lIndex > 0) && (lIndex <= MAX_RRU_ID)) 
				lComp = MATCH_SUCCEEDED;
        }
    }
	else
	{
		ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
		if(ret < 0)
        {
            memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));
			
            if(get_first_rru_id(&lIndex) == 0)
            {				
                lComp = MATCH_SUCCEEDED;
            }
			else
			{
                if(rruInitMsgTable_RowBuf.rruInitMsgRowStatus != SNMP_ROW_NONEXISTENT)
                {
					lComp  = MATCH_SUCCEEDED;
                    lIndex = rruInitMsgTable_RowBuf.rruInitMsgIndex;
                }
			}
        }
		else if(ret == 0)
        {
            if(*length == vp->namelen)
            {
                if(get_first_rru_id(&lIndex) == 0)
                {
                    lComp = MATCH_SUCCEEDED;
                }
			    else
			    {
                    if(rruInitMsgTable_RowBuf.rruInitMsgRowStatus != SNMP_ROW_NONEXISTENT)
                    {
					    lComp  = MATCH_SUCCEEDED;
						lIndex = rruInitMsgTable_RowBuf.rruInitMsgIndex;
                    }
		  	    }
            }
            else if (*length == (vp->namelen + 1))
            {
                lIndex = newname[vp->namelen];
				if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NONEXISTENT) || 
				   (rruInitMsgTable_RowBuf.rruInitMsgIndex != lIndex))
                {
                    if(get_next_rru_id(&lIndex) == 0)
                    {
                        lComp  = MATCH_SUCCEEDED;
                    }
			        else
			        {
                        if(rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NONEXISTENT)
                        {
					        lComp  = MATCH_SUCCEEDED;
                            lIndex = rruInitMsgTable_RowBuf.rruInitMsgIndex;
                        }
		  	        }
                }
            }
        }
	}
	
	if(lComp == MATCH_SUCCEEDED)
	{
	   *length	= vp->namelen + 1;
	   *plIndex = lIndex;
		newname[vp->namelen] = lIndex;
		memcpy(name, newname, (*length) * sizeof(oid));
	}

	return(lComp);
}

/*
 * var_rruInitMsgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_rruInitInfo above.
 */
unsigned char  *
var_rruInitMsgTable
(
	struct variable *vp,
    oid * name,
    size_t *length,
    int exact,
    size_t *var_len, 
    WriteMethod ** write_method
)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	static long VAR = 0;
	long lIndex = 0;
	long flag = 0;
	UINT32 ret = 0;

//    if (header_simple_table
//        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
//        == MATCH_FAILED)
//        return NULL;
	
	ret = header_rruInitMsgTable(vp,name,length,exact,var_len,write_method, &lIndex);
	if (ret != MATCH_SUCCEEDED)
    {
		log_msg(LOG_ERR,MAIN,"rru id match failed\n");
        return (u_char *)NULL;
    }
#if 0
    if(exact)
    {
    	if((vp->magic == RRUINITMSGROWSTATUS) || ((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NONEXISTENT) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex )))
    	{
    		flag = 1;
    	}
		else
		{
			printf("run in 303\n");
			return ((u_char *)NULL);
		}
    }
	else
	{
		flag = 1;
	}
#endif

    switch (vp->magic) {
    case RRUINITMSGINDEX:
        VAR = lIndex;           
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGRRUID:
        *write_method = write_rruInitMsgRruId;
        VAR = lIndex;          
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGSERIALNO:
        *write_method = write_rruInitMsgSerialNo;
		*var_len = strlen(rruInitMsgTable_RowBuf.rruInitMsgSerialNo) + 1;
        memcpy(string, rruInitMsgTable_RowBuf.rruInitMsgSerialNo,*var_len);
        return (u_char *) string;
    case RRUINITMSGPERIOD:
        *write_method = write_rruInitMsgPeriod;
        VAR = rruInitMsgTable_RowBuf.rruInitMsgPeriod;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGVSWRTHRES1:
        *write_method = write_rruInitMsgVswrThres1;
        VAR = rruInitMsgTable_RowBuf.rruInitMsgVswrThres1;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGVSWRTHRES2:
        *write_method = write_rruInitMsgVswrThres2;
        VAR = rruInitMsgTable_RowBuf.rruInitMsgVswrThres2;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGUPTHRES:
        *write_method = write_rruInitMsgUpThres;
        VAR = rruInitMsgTable_RowBuf.rruInitMsgUpThres;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGLOWTHRES:
        *write_method = write_rruInitMsgLowThres;
        VAR = rruInitMsgTable_RowBuf.rruInitMsgLowThres;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGANTMODE:
        *write_method = write_rruInitMsgAntMode;
        VAR = rruInitMsgTable_RowBuf.rruInitMsgAntMode;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGANTSETNO:
        *write_method = write_rruInitMsgAntSetNo;
        VAR = rruInitMsgTable_RowBuf.rruInitMsgAntSetNo;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGANTSTATE:
        *write_method = write_rruInitMsgAntState;
        VAR = rruInitMsgTable_RowBuf.rruInitMsgAntState;      
		*var_len = sizeof(VAR);
        return (u_char *) & VAR;
    case RRUINITMSGUPPATHSTATE:
        *write_method = write_rruInitMsgUpPathState;
		*var_len = strlen(rruInitMsgTable_RowBuf.rruInitMsgUpPathState) + 1;
        memcpy(string, rruInitMsgTable_RowBuf.rruInitMsgUpPathState, *var_len);
        return (u_char *) string;
    case RRUINITMSGDWPATHSTATE:
        *write_method = write_rruInitMsgDwPathState;
        *var_len = strlen(rruInitMsgTable_RowBuf.rruInitMsgDwPathState) + 1;
        memcpy(string, rruInitMsgTable_RowBuf.rruInitMsgDwPathState, *var_len);
        return (u_char *) string;
    case RRUINITMSGROWSTATUS:
        *write_method = write_rruInitMsgRowStatus;
		VAR = rruInitMsgTable_RowBuf.rruInitMsgRowStatus;	  
	    *var_len = sizeof(VAR);
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int
write_rruInitMsgRruId(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruInitInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgSerialNo(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	long 			lIndex = 0;


    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to rruInitInfo not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(rruInitMsgTable_RowBuf.rruInitMsgSerialNo)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	memcpy(&rruInitMsgTable_RowBuf.rruInitMsgSerialNo, var_val, size);
			setbit(rruInitMsgTable_RowBuf.fin_flag,1);

		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgPeriod(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruInitInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	rruInitMsgTable_RowBuf.rruInitMsgPeriod = value;
			setbit(rruInitMsgTable_RowBuf.fin_flag,2);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgVswrThres1(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruInitInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	rruInitMsgTable_RowBuf.rruInitMsgVswrThres1 = value;
			setbit(rruInitMsgTable_RowBuf.fin_flag,3);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgVswrThres2(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruInitInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	rruInitMsgTable_RowBuf.rruInitMsgVswrThres2 = value;
			setbit(rruInitMsgTable_RowBuf.fin_flag,4);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
        
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgUpThres(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	long			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruInitInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	rruInitMsgTable_RowBuf.rruInitMsgUpThres = value;
			setbit(rruInitMsgTable_RowBuf.fin_flag,5);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgLowThres(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruInitInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	rruInitMsgTable_RowBuf.rruInitMsgLowThres = value;
			setbit(rruInitMsgTable_RowBuf.fin_flag,6);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgAntMode(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruInitInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	rruInitMsgTable_RowBuf.rruInitMsgAntMode = value;
			setbit(rruInitMsgTable_RowBuf.fin_flag,7);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgAntSetNo(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruInitInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	rruInitMsgTable_RowBuf.rruInitMsgAntSetNo = value;
			setbit(rruInitMsgTable_RowBuf.fin_flag,8);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgAntState(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to rruInitInfo not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		value = *(u_long*)var_val;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	rruInitMsgTable_RowBuf.rruInitMsgAntState = value;
			setbit(rruInitMsgTable_RowBuf.fin_flag,9);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgUpPathState(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to rruInitInfo not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(rruInitMsgTable_RowBuf.rruInitMsgUpPathState)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	memcpy(&rruInitMsgTable_RowBuf.rruInitMsgUpPathState, var_val, size);
			setbit(rruInitMsgTable_RowBuf.fin_flag,10);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgDwPathState(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	long 			lIndex;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to rruInitInfo not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(rruInitMsgTable_RowBuf.rruInitMsgDwPathState)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		size = var_val_len;
		if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) && (rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
        {
        	memcpy(&rruInitMsgTable_RowBuf.rruInitMsgDwPathState, var_val, size);
			setbit(rruInitMsgTable_RowBuf.fin_flag,11);
		}
		else
		{
			return SNMP_ERR_WRONGVALUE;
		}
       
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rruInitMsgRowStatus(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	
	long 			lVar = 0;
	long 			lIndex = 0;
	ICR_INIT_INFO_RRU rru_init_msg;
	INT32 rru_init_msg_len;
	rru_init_msg_len = sizeof(ICR_INIT_INFO_RRU);
	memset(&rru_init_msg, 0, sizeof(rru_init_msg));

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to rruInitInfo not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to rruInitInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		lVar = *(long *)var_val;
        if((lVar < 0) || (lVar > 6)) 
			return(SNMP_ERR_WRONGVALUE);
	    lIndex = name[RRUINITINFOTABLE_INDEX_POS];
		switch(lVar)
		{
			case SNMP_ROW_CREATEANDWAIT:
				memset(&rruInitMsgTable_RowBuf, 0x00, sizeof(rruInitMsgTable_RowBuf));
				rruInitMsgTable_RowBuf.rruInitMsgIndex  = lIndex;
		  		rruInitMsgTable_RowBuf.rruInitMsgRowStatus = SNMP_ROW_NOTINSERVICE;

			    break;
			case SNMP_ROW_ACTIVE:
				if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus == SNMP_ROW_NOTINSERVICE) &&
					(rruInitMsgTable_RowBuf.fin_flag == 0X0FFE))
				{
					rru_init_msg.head.msg_type = MODULE_CFIG_MGMT;
					rru_init_msg.head.msg_code = SET_INIT_INFO_RRU;
					rru_init_msg.head.msg_len = rru_init_msg_len;
					memcpy(rru_init_msg.serial_no, rruInitMsgTable_RowBuf.rruInitMsgSerialNo, RRU_SN_LEN);
					rru_init_msg.period = rruInitMsgTable_RowBuf.rruInitMsgPeriod;
					rru_init_msg.vswr_thres1 = rruInitMsgTable_RowBuf.rruInitMsgVswrThres1;
					rru_init_msg.vswr_thres2= rruInitMsgTable_RowBuf.rruInitMsgVswrThres2;
					rru_init_msg.up_thres = rruInitMsgTable_RowBuf.rruInitMsgUpThres;
					rru_init_msg.low_thres = rruInitMsgTable_RowBuf.rruInitMsgLowThres;
					rru_init_msg.ant_mode = rruInitMsgTable_RowBuf.rruInitMsgAntMode;
					rru_init_msg.ant_set_no = rruInitMsgTable_RowBuf.rruInitMsgAntSetNo;
					rru_init_msg.ant_state = rruInitMsgTable_RowBuf.rruInitMsgAntState;
					charVec2intVec(&rru_init_msg.up_path_state, &rruInitMsgTable_RowBuf.rruInitMsgUpPathState, RRU_PATH_STATE_LEN);
				    charVec2intVec(&rru_init_msg.dw_path_state, &rruInitMsgTable_RowBuf.rruInitMsgDwPathState, RRU_PATH_STATE_LEN);
					
					if(send_msg_to_om(MODULE_RRUS_MGMT, (char*)&rru_init_msg, rru_init_msg_len) != 0)
					{
						return (SNMP_ERR_COMMITFAILED);
					}					
					memset(&rruInitMsgTable_RowBuf, 0, sizeof(rruInitMsgTable_RowBuf));
					rruInitMsgTable_RowBuf.rruInitMsgRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else
					return (SNMP_ERR_COMMITFAILED);
				break;
			case SNMP_ROW_DESTROY:
				if((rruInitMsgTable_RowBuf.rruInitMsgRowStatus != SNMP_ROW_NONEXISTENT) &&
					(rruInitMsgTable_RowBuf.rruInitMsgIndex == lIndex))
				{
					memset(&rruInitMsgTable_RowBuf, 0, sizeof(rruInitMsgTable_RowBuf));
					rruInitMsgTable_RowBuf.rruInitMsgRowStatus = SNMP_ROW_NONEXISTENT;
				}
				else 
					return (SNMP_ERR_WRONGVALUE);
				break;
			default:
				return (SNMP_ERR_WRONGVALUE);
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}
