/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:33 CST. */
/* 
 Copyright (C) Rong Tao @Beijing

 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.3
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
 Texts. A copy of the license is included in the section entitled ‘‘GNU
 Free Documentation License’’.
   2019年 03月 14日 星期四 19:24:45 CST. 
*/
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 08日 星期五 08:10:29 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:28:04 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "fpgaHealthMsg.h"
#include "mnt_mgmt_api.h"

//#include "bord_mgmt_api.h"
//#include "bord_mgmt_set_api.h"
#include "om_common_h.h"
/*
 * fpgaHealthMsg_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define FPGAHEALTH_INDEX_POS    16
oid             fpgaHealthMsg_variables_oid[] =
    { 1, 3, 6, 1, 4, 1, 12001, 1, 2, 3, 2, 1, 2 };

/*
 * variable4 fpgaHealthMsg_variables:
 *   this variable defines function callbacks and type return information 
 *   for the fpgaHealthMsg mib section 
 */

struct variable4 fpgaHealthMsg_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */
#define FPGAHEALTHMSGFPGASERVERID		1
    {FPGAHEALTHMSGFPGASERVERID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_fpgaHealthMsg, 1, {1}},
#define FPGAHEALTHMSGFPGASERVERFANTHRES		2
    {FPGAHEALTHMSGFPGASERVERFANTHRES, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_fpgaHealthMsg, 1, {2}},
#define FPGAHEALTHMSGFPGASERVERFAN		3
    {FPGAHEALTHMSGFPGASERVERFAN, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_fpgaHealthMsg, 1, {3}},

#define FPGAHEALTHMSGINDEX		1
    {FPGAHEALTHMSGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_fpgaHealthMsgTable, 3, {4, 1, 1}},
#define FPGAHEALTHMSGFPGAID		2
    {FPGAHEALTHMSGFPGAID, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_fpgaHealthMsgTable, 3, {4, 1, 2}},
#define FPGAHEALTHMSGFPGATEMPTHRES		3
    {FPGAHEALTHMSGFPGATEMPTHRES, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_fpgaHealthMsgTable, 3, {4, 1, 3}},
#define FPGAHEALTHMSGFPGATEMP		4
    {FPGAHEALTHMSGFPGATEMP, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_fpgaHealthMsgTable, 3, {4, 1, 4}},
#define FPGAHEALTHMSGFPGAVOLTHRES		5
    {FPGAHEALTHMSGFPGAVOLTHRES, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_fpgaHealthMsgTable, 3, {4, 1, 5}},
#define FPGAHEALTHMSGFPGAVOL		6
    {FPGAHEALTHMSGFPGAVOL, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_fpgaHealthMsgTable, 3, {4, 1, 6}},
#define FPGAHEALTHMSGROWSTATUS		7
    {FPGAHEALTHMSGROWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_fpgaHealthMsgTable, 3, {4, 1, 7}},
};

/*
 * (L = length of the oidsuffix) 
 */


/** Initializes the fpgaHealthMsg module */
void
init_fpgaHealthMsg(void)
{

    DEBUGMSGTL(("fpgaHealthMsg", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("fpgaHealthMsg", fpgaHealthMsg_variables, variable4,
                 fpgaHealthMsg_variables_oid);

    /*
     * place any other initialization junk you need here 
     */
}

/*
 * var_fpgaHealthMsg():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_fpgaHealthMsg(struct variable *vp,
                  oid * name,
                  size_t *length,
                  int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	static unsigned long ulVar;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case FPGAHEALTHMSGFPGASERVERID:
        *write_method = write_fpgaHealthMsgFpgaServerId;
	    long_ret=CTRL_FPGA_Healthres_Get_fpga_server_id(&ulVar);
        *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;
    case FPGAHEALTHMSGFPGASERVERFANTHRES:
        *write_method = write_fpgaHealthMsgFpgaServerFanThres;
	    long_ret=CTRL_FPGA_Healthres_Get_fpga_server_fan_thres(&ulVar);
        *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;
    case FPGAHEALTHMSGFPGASERVERFAN:
        *write_method = write_fpgaHealthMsgFpgaServerFan;
	    long_ret=CTRL_FPGA_Health_Get_fpga_server_fan(&ulVar);
        *var_len = sizeof(ulVar);
        return (u_char *) & ulVar;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

 /* fpgaAssetMsgTable表索引处理数 */
long header_fpgaHealthMsgTable
(
	struct variable *vp,
    oid		   *name,
	size_t	   *length,
	int			exact,
	size_t	   *var_len,
	WriteMethod **write_method,
	long			   *plIndex
)
{
	long	  ret		  = 0;
	long	  lComp 	  = MATCH_FAILED;
	long	  lIndex	  = 0;
	oid newname[MAX_OID_LEN];
								   
	memset(newname, 0x00, sizeof(newname));
	memcpy(newname, name, (*length) * sizeof(oid));
								   
	if(exact)   /* get/set  */
	{
		ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
		if((ret == 0) && (*length == (vp->namelen + 1)))
		{
			lIndex = newname[vp->namelen];
			if((lIndex > 0) && (lIndex <= MAX_CONTRL_DEVICE_SUM)) lComp = MATCH_SUCCEEDED;
		}
	}
	else		   /* get-next */
	{
	    ret = snmp_oid_compare(newname, vp->namelen, vp->name, vp->namelen);
								   
	    if(ret < 0)					   /* name中的OID比注册信息中的OID靠前 */
	    {
				memcpy(newname, vp->name, (vp->namelen) * sizeof(oid));
				lComp = MATCH_SUCCEEDED;
				lIndex = 1;
	   }
	   else if(ret == 0)
	   {
		   if(*length == vp->namelen)	/* 没有带索引	  */
		   {
			   lComp = MATCH_SUCCEEDED;
			   lIndex = 1;
		   }
		   else if (*length == (vp->namelen + 1)) /* 有参照索引    */
		   {
			   lIndex = newname[vp->namelen];
			   lIndex += 1;
			   if((lIndex > 0) && (lIndex <= MAX_CONTRL_DEVICE_SUM)) lComp = MATCH_SUCCEEDED;
		   }
		}
	}
	if(lComp == MATCH_SUCCEEDED)
	{
		*length  = vp->namelen + 1;
		*plIndex = lIndex;
		newname[vp->namelen] = lIndex;
		memcpy(name, newname, (*length) * sizeof(oid));
	}
								   
	return(lComp);
}

/*
 * var_fpgaHealthMsgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_fpgaHealthMsg above.
 */
unsigned char  *
var_fpgaHealthMsgTable(struct variable *vp,
                       oid * name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	static long lIndex;
	static unsigned long ulVar=0;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
	if (header_fpgaHealthMsgTable
			(vp,name,length,exact,var_len,write_method, &lIndex)
			== MATCH_FAILED)
			return NULL;


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case FPGAHEALTHMSGINDEX:
         ulVar= lIndex;    
	    *var_len = sizeof(ulVar);
        return ((unsigned char *) & ulVar);
    case FPGAHEALTHMSGFPGAID:
        *write_method = write_fpgaHealthMsgFpgaId;
		long_ret = CTRL_FPGA_Healthres_Get_fpga_id(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);	
        return (u_char *) & ulVar;
    case FPGAHEALTHMSGFPGATEMPTHRES:
        *write_method = write_fpgaHealthMsgFpgaTempThres;
		long_ret = CTRL_FPGA_Healthres_Get_fpga_temp_thres(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);	
        return (u_char *) & ulVar;
    case FPGAHEALTHMSGFPGATEMP:
        *write_method = write_fpgaHealthMsgFpgaTemp;
		long_ret = CTRL_FPGA_HealthInfo_Get_fpga_temp(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);	
        return (u_char *) & ulVar;

    case FPGAHEALTHMSGFPGAVOLTHRES:
        *write_method = write_fpgaHealthMsgFpgaVolThres;
		long_ret = CTRL_FPGA_Healthres_Get_fpga_vol_thres(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);	
        return (u_char *) & ulVar;

    case FPGAHEALTHMSGFPGAVOL:
        *write_method = write_fpgaHealthMsgFpgaVol;
		long_ret = CTRL_FPGA_HealthInfo_Get_fpga_vol(lIndex,&ulVar);
	    *var_len = sizeof(ulVar);	
        return (u_char *) & ulVar;
    case FPGAHEALTHMSGROWSTATUS:
        *write_method = write_fpgaHealthMsgRowStatus;	
        return (u_char *) & lIndex;

    default:
        ERROR_MSG("");
    }
    return NULL;
}



int
write_fpgaHealthMsgFpgaServerId(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to fpgaHealthMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to fpgaHealthMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_fpgaHealthMsgFpgaServerFanThres(int action,
                                      u_char * var_val,
                                      u_char var_val_type,
                                      size_t var_val_len,
                                      u_char * statP,
                                      oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    FpgaServerFanThresConf fpgaServerFanThersConf;
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to fpgaHealthMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to fpgaHealthMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
//		if(CTRL_FPGA_Health_Set_fpga_server_fan_thres(&value)!=SUCCESS)
//		{
//		    return SNMP_ERR_WRONGTYPE;
//		}
    	fpgaServerFanThersConf.msghead.msg_type = MODULE_CFIG_MGMT;
    	fpgaServerFanThersConf.msghead.msg_code = CFG_MGMT_BORD_MGMT_FPGA_FAN_THRES_CFG_REQ;
    	fpgaServerFanThersConf.msghead.msg_len = sizeof(FpgaServerFanThresConf);
    	fpgaServerFanThersConf.fpga_server_fan_thres = *(u_long *) var_val;
        if (send_msg_to_om(MODULE_BORD_MGMT,(char*)&fpgaServerFanThersConf,sizeof(FpgaServerFanThresConf)) != 0)
        {
        	return SNMP_ERR_COMMITFAILED;
        }
//        send_msg_to_om(MODULE_BORD_MGMT,(char*)&fpgaServerFanThersConf,sizeof(FpgaServerFanThresConf));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_fpgaHealthMsgFpgaServerFan(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to fpgaHealthMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to fpgaHealthMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_fpgaHealthMsgFpgaId(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to fpgaHealthMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to fpgaHealthMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_fpgaHealthMsgFpgaTempThres(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    u_long          value;
    int             size;
    u_long          ulIndex;
    FpgaTempThresConf fpgaTempThresConf;
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to fpgaHealthMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to fpgaHealthMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
		
	    ulIndex = name[FPGAHEALTH_INDEX_POS];
//		if(CTRL_FPGA_HealthInfo_Set_fpga_temp_thres(ulIndex,&value)!=SUCCESS)
//		{
//		    return SNMP_ERR_WRONGTYPE;
//		}
		fpgaTempThresConf.msghead.msg_type = MODULE_CFIG_MGMT;
		fpgaTempThresConf.msghead.msg_code = CFG_MGM_BORD_MGMT_FPGA_TEMP_THRES_CFG_REQ;
		fpgaTempThresConf.msghead.msg_len = sizeof(FpgaTempThresConf);
		fpgaTempThresConf.fpga_index = ulIndex;
		fpgaTempThresConf.fpga_temp_thres = *(u_long *) var_val;
        if (send_msg_to_om(MODULE_BORD_MGMT,(char*)&fpgaTempThresConf,sizeof(FpgaTempThresConf)) != 0)
        {
        	return SNMP_ERR_COMMITFAILED;
        }
//        send_msg_to_om(MODULE_BORD_MGMT,(char*)&fpgaTempThresConf,sizeof(FpgaTempThresConf));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_fpgaHealthMsgFpgaTemp(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to fpgaHealthMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to fpgaHealthMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_fpgaHealthMsgFpgaVolThres(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	u_long          ulIndex;
	FpgaVolThresConf fpgaVolThresConf;
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to fpgaHealthMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to fpgaHealthMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        ulIndex = name[FPGAHEALTH_INDEX_POS];
//		if(CTRL_FPGA_HealthInfo_Set_fpga_vol_thres(ulIndex,&value)!=SUCCESS)
//		{
//		    return SNMP_ERR_WRONGTYPE;
//		}
		fpgaVolThresConf.msghead.msg_type = MODULE_CFIG_MGMT;
		fpgaVolThresConf.msghead.msg_code = CFG_MGMT_BORD_MGMT_FPGA_VOL_THRES_CFG_REQ;
		fpgaVolThresConf.msghead.msg_len = sizeof(FpgaVolThresConf);
		fpgaVolThresConf.fpga_index = ulIndex;
		fpgaVolThresConf.fpga_vol_thres = *(u_long *) var_val;
        if (send_msg_to_om(MODULE_BORD_MGMT,(char*)&fpgaVolThresConf,sizeof(FpgaVolThresConf)) != 0)
        {
        	return SNMP_ERR_COMMITFAILED;
        }
//        send_msg_to_om(MODULE_BORD_MGMT,(char*)&fpgaVolThresConf,sizeof(FpgaVolThresConf));
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_fpgaHealthMsgFpgaVol(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to fpgaHealthMsg not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to fpgaHealthMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_fpgaHealthMsgRowStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to fpgaHealthMsg not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to fpgaHealthMsg: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}
