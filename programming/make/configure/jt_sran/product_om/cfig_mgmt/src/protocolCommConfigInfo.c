/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:06:33 CST. */
/* 
 Copyright (C) Rong Tao @Beijing

 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.3
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
 Texts. A copy of the license is included in the section entitled ‘‘GNU
 Free Documentation License’’.
   2019年 03月 14日 星期四 19:24:45 CST. 
*/
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 08日 星期五 08:10:29 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:28:04 CST. */
/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "protocolCommConfigInfo.h"

static int ret = 0;
char cfg_dic[STR_LEN_256];
char table_info_int_value[12];

struct protocolCommConfigTable_entry *protocolCommConfigTable_head;
struct protocolAccessConfigTable_entry *protocolAccessConfigTable_head;
struct protocolPowerConfigTable_entry *protocolPowerConfigTable_head;
struct protocolLogConfigTable_entry *protocolLogConfigTable_head;

/** Initializes the protocolCommConfigInfo module */
void
init_protocolCommConfigInfo(void)
{
    initialize_table_protocolCommConfigTable();
    initialize_table_protocolAccessConfigTable();
    initialize_table_protocolPowerConfigTable();
    initialize_table_protocolLogConfigTable();
}


/** Initialize the protocolCommConfigTable table by defining its contents and how it's structured */
void
initialize_table_protocolCommConfigTable(void)
{
    const oid       protocolCommConfigTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 1 };
    const size_t    protocolCommConfigTable_oid_len =
        OID_LENGTH(protocolCommConfigTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("protocolCommConfigInfo:init",
                "initializing table protocolCommConfigTable\n"));

    reg =
        netsnmp_create_handler_registration("protocolCommConfigTable",
                                            protocolCommConfigTable_handler,
                                            protocolCommConfigTable_oid,
                                            protocolCommConfigTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: protocolCommConfigeIndex */
                                     0);
    table_info->min_column = COLUMN_PROTOCOLCOMMCONFIGENODEBID;
    table_info->max_column = COLUMN_PROTOCOLCOMMCONFIGROWSTATUS;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point =
        protocolCommConfigTable_get_first_data_point;
    iinfo->get_next_data_point =
        protocolCommConfigTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    /*
     * Initialise the contents of the table here 
     */
}



/*
 * create a new row in the (unsorted) table 
 */
struct protocolCommConfigTable_entry *
protocolCommConfigTable_createEntry(u_long protocolCommConfigeIndex)
{
    struct protocolCommConfigTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct protocolCommConfigTable_entry);
    if (!entry)
        return NULL;

    entry->protocolCommConfigeIndex = protocolCommConfigeIndex;
    entry->next = protocolCommConfigTable_head;
    protocolCommConfigTable_head = entry;
    return entry;
}

/*
 * remove a row from the table 
 */
void
protocolCommConfigTable_removeEntry(struct protocolCommConfigTable_entry
                                    *entry)
{
    struct protocolCommConfigTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = protocolCommConfigTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        protocolCommConfigTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}


/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
protocolCommConfigTable_get_first_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
    *my_loop_context = protocolCommConfigTable_head;
    return protocolCommConfigTable_get_next_data_point(my_loop_context,
                                                       my_data_context,
                                                       put_index_data,
                                                       mydata);
}

netsnmp_variable_list *
protocolCommConfigTable_get_next_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
    struct protocolCommConfigTable_entry *entry =
        (struct protocolCommConfigTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_UNSIGNED,
                                   entry->protocolCommConfigeIndex);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the protocolCommConfigTable table */
int
protocolCommConfigTable_handler(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct protocolCommConfigTable_entry *table_entry;
    struct protocolCommConfigTable_entry *table_row;

    DEBUGMSGTL(("protocolCommConfigInfo:handler",
                "Processing request (%d)\n", reqinfo->mode));


    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolCommConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLCOMMCONFIGENODEBID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolCommConfigeNodebID);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGENODEBIP:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigeNodebIP,
                                         table_entry->
                                         protocolCommConfigeNodebIP_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGMMEIPADDR:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigMMEIPAddr,
                                         table_entry->
                                         protocolCommConfigMMEIPAddr_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSGWIPADDR:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigSGWIPAddr,
                                         table_entry->
                                         protocolCommConfigSGWIPAddr_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGFTPIP:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigFTPIP,
                                         table_entry->
                                         protocolCommConfigFTPIP_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGCELLIDENTITY:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolCommConfigCellIdentity);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGVBSID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolCommConfigVBSID);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGVBSMODE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigVBSMode,
                                         table_entry->
                                         protocolCommConfigVBSMode_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGDLBANDWIDTH:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigDLBandwidth,
                                         table_entry->
                                         protocolCommConfigDLBandwidth_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGULBANDWIDTH:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigULBandwidth,
                                         table_entry->
                                         protocolCommConfigULBandwidth_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGFREQBANDINDICATOR:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolCommConfigFreqBandIndicator);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGDLCARRIERFREQ:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolCommConfigDLCarrierFreq);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGULCARRIERFREQ:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolCommConfigULCarrierFreq);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSUBFRAMEASSIGNMENT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigSubFrameAssignment,
                                         table_entry->
                                         protocolCommConfigSubFrameAssignment_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSPECIALSUBFRAMEPAT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigSpecialSubFramePat,
                                         table_entry->
                                         protocolCommConfigSpecialSubFramePat_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGPHYCELLID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolCommConfigPhyCellID);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGTXANTPORT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolCommConfigTxAntPort);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGRXANTPORT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolCommConfigRxAntPort);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGPLMDID:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigPlmdID,
                                         table_entry->
                                         protocolCommConfigPlmdID_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGTRACKINGAREACODE:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolCommConfigTrackingAreaCode,
                                         table_entry->
                                         protocolCommConfigTrackingAreaCode_len);
                break;
            case COLUMN_PROTOCOLCOMMCONFIGROWSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           protocolCommConfigRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolCommConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLCOMMCONFIGENODEBID:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGENODEBIP:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigeNodebIP));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGMMEIPADDR:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigMMEIPAddr));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSGWIPADDR:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigSGWIPAddr));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGFTPIP:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigFTPIP));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGCELLIDENTITY:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGVBSID:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGVBSMODE:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigVBSMode));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGDLBANDWIDTH:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigDLBandwidth));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGULBANDWIDTH:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigULBandwidth));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGFREQBANDINDICATOR:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGDLCARRIERFREQ:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGULCARRIERFREQ:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSUBFRAMEASSIGNMENT:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigSubFrameAssignment));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSPECIALSUBFRAMEPAT:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigSpecialSubFramePat));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGPHYCELLID:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGTXANTPORT:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGRXANTPORT:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGPLMDID:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigPlmdID));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGTRACKINGAREACODE:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolCommConfigTrackingAreaCode));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGROWSTATUS:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolCommConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLCOMMCONFIGENODEBID:
            case COLUMN_PROTOCOLCOMMCONFIGENODEBIP:
            case COLUMN_PROTOCOLCOMMCONFIGMMEIPADDR:
            case COLUMN_PROTOCOLCOMMCONFIGSGWIPADDR:
            case COLUMN_PROTOCOLCOMMCONFIGFTPIP:
            case COLUMN_PROTOCOLCOMMCONFIGCELLIDENTITY:
            case COLUMN_PROTOCOLCOMMCONFIGVBSID:
            case COLUMN_PROTOCOLCOMMCONFIGVBSMODE:
            case COLUMN_PROTOCOLCOMMCONFIGDLBANDWIDTH:
            case COLUMN_PROTOCOLCOMMCONFIGULBANDWIDTH:
            case COLUMN_PROTOCOLCOMMCONFIGFREQBANDINDICATOR:
            case COLUMN_PROTOCOLCOMMCONFIGDLCARRIERFREQ:
            case COLUMN_PROTOCOLCOMMCONFIGULCARRIERFREQ:
            case COLUMN_PROTOCOLCOMMCONFIGSUBFRAMEASSIGNMENT:
            case COLUMN_PROTOCOLCOMMCONFIGSPECIALSUBFRAMEPAT:
            case COLUMN_PROTOCOLCOMMCONFIGPHYCELLID:
            case COLUMN_PROTOCOLCOMMCONFIGTXANTPORT:
            case COLUMN_PROTOCOLCOMMCONFIGRXANTPORT:
            case COLUMN_PROTOCOLCOMMCONFIGPLMDID:
            case COLUMN_PROTOCOLCOMMCONFIGTRACKINGAREACODE:
            case COLUMN_PROTOCOLCOMMCONFIGROWSTATUS:
            	switch (*request->requestvb->val.integer){
            	case RS_CREATEANDGO:
            	case RS_CREATEANDWAIT:
            		table_row = protocolCommConfigTable_createEntry(*table_info->indexes->val.integer);
            		if (table_row){
            			netsnmp_insert_iterator_context(request,table_row);

            			//generate a new file
            			char *procfgdic = generate_protocol_dic(cfg_dic,*table_info->indexes->val.integer);
            			if ( g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic == NULL || strcmp(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic, procfgdic) != 0)
            			{
            				ret = generate_protocol_docu(PROTOCOL_CFG_DEFAULT, procfgdic);
            				memcpy(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic,procfgdic,sizeof(char)*256);
            			}


            		}
            		else{
            			netsnmp_set_request_error(reqinfo, request,SNMP_ERR_RESOURCEUNAVAILABLE);
            			return SNMP_ERR_NOERROR;
            		}
            		break;
            	}
                break;
            }
        }
        break;

    case MODE_SET_FREE:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolCommConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLCOMMCONFIGENODEBID:
            case COLUMN_PROTOCOLCOMMCONFIGENODEBIP:
            case COLUMN_PROTOCOLCOMMCONFIGMMEIPADDR:
            case COLUMN_PROTOCOLCOMMCONFIGSGWIPADDR:
            case COLUMN_PROTOCOLCOMMCONFIGFTPIP:
            case COLUMN_PROTOCOLCOMMCONFIGCELLIDENTITY:
            case COLUMN_PROTOCOLCOMMCONFIGVBSID:
            case COLUMN_PROTOCOLCOMMCONFIGVBSMODE:
            case COLUMN_PROTOCOLCOMMCONFIGDLBANDWIDTH:
            case COLUMN_PROTOCOLCOMMCONFIGULBANDWIDTH:
            case COLUMN_PROTOCOLCOMMCONFIGFREQBANDINDICATOR:
            case COLUMN_PROTOCOLCOMMCONFIGDLCARRIERFREQ:
            case COLUMN_PROTOCOLCOMMCONFIGULCARRIERFREQ:
            case COLUMN_PROTOCOLCOMMCONFIGSUBFRAMEASSIGNMENT:
            case COLUMN_PROTOCOLCOMMCONFIGSPECIALSUBFRAMEPAT:
            case COLUMN_PROTOCOLCOMMCONFIGPHYCELLID:
            case COLUMN_PROTOCOLCOMMCONFIGTXANTPORT:
            case COLUMN_PROTOCOLCOMMCONFIGRXANTPORT:
            case COLUMN_PROTOCOLCOMMCONFIGPLMDID:
            case COLUMN_PROTOCOLCOMMCONFIGTRACKINGAREACODE:
            case COLUMN_PROTOCOLCOMMCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_entry);
                }
                break;
            }
        }
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolCommConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
            char *docpath = g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic;
            switch (table_info->colnum) {
            case COLUMN_PROTOCOLCOMMCONFIGENODEBID:
                table_entry->old_protocolCommConfigeNodebID =
                    table_entry->protocolCommConfigeNodebID;
                table_entry->protocolCommConfigeNodebID =
                    *request->requestvb->val.integer;

                break;
            case COLUMN_PROTOCOLCOMMCONFIGENODEBIP:
                memcpy(table_entry->old_protocolCommConfigeNodebIP,
                       table_entry->protocolCommConfigeNodebIP,
                       sizeof(table_entry->protocolCommConfigeNodebIP));
                table_entry->old_protocolCommConfigeNodebIP_len =
                    table_entry->protocolCommConfigeNodebIP_len;
                memset(table_entry->protocolCommConfigeNodebIP, 0,
                       sizeof(table_entry->protocolCommConfigeNodebIP));
                memcpy(table_entry->protocolCommConfigeNodebIP,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigeNodebIP_len =
                    request->requestvb->val_len;

                if (docpath)
                {
                	ret = modify_cfg_file(docpath, Cfg_enb_ipaddr, table_entry->protocolCommConfigeNodebIP, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG, 0);
                	ret = modify_cfg_file(docpath, Cfg_gtpu_recv_addr, table_entry->protocolCommConfigeNodebIP, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG, 0);
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGMMEIPADDR:
                memcpy(table_entry->old_protocolCommConfigMMEIPAddr,
                       table_entry->protocolCommConfigMMEIPAddr,
                       sizeof(table_entry->protocolCommConfigMMEIPAddr));
                table_entry->old_protocolCommConfigMMEIPAddr_len =
                    table_entry->protocolCommConfigMMEIPAddr_len;
                memset(table_entry->protocolCommConfigMMEIPAddr, 0,
                       sizeof(table_entry->protocolCommConfigMMEIPAddr));
                memcpy(table_entry->protocolCommConfigMMEIPAddr,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigMMEIPAddr_len =
                    request->requestvb->val_len;

                if (docpath)
                {
                	ret = modify_cfg_file(docpath, Cfg_mme_ipaddr, table_entry->protocolCommConfigMMEIPAddr, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSGWIPADDR:
                memcpy(table_entry->old_protocolCommConfigSGWIPAddr,
                       table_entry->protocolCommConfigSGWIPAddr,
                       sizeof(table_entry->protocolCommConfigSGWIPAddr));
                table_entry->old_protocolCommConfigSGWIPAddr_len =
                    table_entry->protocolCommConfigSGWIPAddr_len;
                memset(table_entry->protocolCommConfigSGWIPAddr, 0,
                       sizeof(table_entry->protocolCommConfigSGWIPAddr));
                memcpy(table_entry->protocolCommConfigSGWIPAddr,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigSGWIPAddr_len =
                    request->requestvb->val_len;
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, Cfg_sgw_ipaddr, table_entry->protocolCommConfigSGWIPAddr, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGFTPIP:
                memcpy(table_entry->old_protocolCommConfigFTPIP,
                       table_entry->protocolCommConfigFTPIP,
                       sizeof(table_entry->protocolCommConfigFTPIP));
                table_entry->old_protocolCommConfigFTPIP_len =
                    table_entry->protocolCommConfigFTPIP_len;
                memset(table_entry->protocolCommConfigFTPIP, 0,
                       sizeof(table_entry->protocolCommConfigFTPIP));
                memcpy(table_entry->protocolCommConfigFTPIP,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigFTPIP_len =
                    request->requestvb->val_len;
                break;
            case COLUMN_PROTOCOLCOMMCONFIGCELLIDENTITY:
                table_entry->old_protocolCommConfigCellIdentity =
                    table_entry->protocolCommConfigCellIdentity;
                table_entry->protocolCommConfigCellIdentity =
                    *request->requestvb->val.integer;
                unsigned char cellid = *request->requestvb->val.integer;
                char bit[STR_LEN_PROTOCOL_28+1] = {0};
                int i = 0;
                for ( i=STR_LEN_PROTOCOL_28-1;i>= 0;i--)
                {
                	if (i >= 20)
                	{
                		bit[i] = (0x01 &cellid) + '0';
                		cellid>>= 1;
                	}
                	else
                	{
                	    bit[i] = '0';
                	}
                }
                bit[STR_LEN_PROTOCOL_28] = '\0';
                printf("bit is %s \n", bit);
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, SICfg_cellIdentity, bit, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
                    ret = modify_cfg_file(docpath, Cfg_cellid, bit, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }

                break;
            case COLUMN_PROTOCOLCOMMCONFIGVBSID:
                table_entry->old_protocolCommConfigVBSID =
                    table_entry->protocolCommConfigVBSID;
                table_entry->protocolCommConfigVBSID =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, Cfg_vbs_id, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGVBSMODE:
                memcpy(table_entry->old_protocolCommConfigVBSMode,
                       table_entry->protocolCommConfigVBSMode,
                       sizeof(table_entry->protocolCommConfigVBSMode));
                table_entry->old_protocolCommConfigVBSMode_len =
                    table_entry->protocolCommConfigVBSMode_len;
                memset(table_entry->protocolCommConfigVBSMode, 0,
                       sizeof(table_entry->protocolCommConfigVBSMode));
                memcpy(table_entry->protocolCommConfigVBSMode,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigVBSMode_len =
                    request->requestvb->val_len;
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, Cfg_vbs_mode, table_entry->protocolCommConfigVBSMode, OPERATE_MODIFY_NAME, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGDLBANDWIDTH:
                memcpy(table_entry->old_protocolCommConfigDLBandwidth,
                       table_entry->protocolCommConfigDLBandwidth,
                       sizeof(table_entry->protocolCommConfigDLBandwidth));
                table_entry->old_protocolCommConfigDLBandwidth_len =
                    table_entry->protocolCommConfigDLBandwidth_len;
                memset(table_entry->protocolCommConfigDLBandwidth, 0,
                       sizeof(table_entry->protocolCommConfigDLBandwidth));
                memcpy(table_entry->protocolCommConfigDLBandwidth,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigDLBandwidth_len =
                    request->requestvb->val_len;
                if (docpath)
                {
                	ret = modify_cfg_file(docpath, SICfg_DllBandWidth, table_entry->protocolCommConfigDLBandwidth, OPERATE_MODIFY_NAME, FILE_TYPE_SICFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGULBANDWIDTH:
                memcpy(table_entry->old_protocolCommConfigULBandwidth,
                       table_entry->protocolCommConfigULBandwidth,
                       sizeof(table_entry->protocolCommConfigULBandwidth));
                table_entry->old_protocolCommConfigULBandwidth_len =
                    table_entry->protocolCommConfigULBandwidth_len;
                memset(table_entry->protocolCommConfigULBandwidth, 0,
                       sizeof(table_entry->protocolCommConfigULBandwidth));
                memcpy(table_entry->protocolCommConfigULBandwidth,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigULBandwidth_len =
                    request->requestvb->val_len;
                if (docpath)
                {
                	ret = modify_cfg_file(docpath, SICfg_UlBandWidth, table_entry->protocolCommConfigULBandwidth, OPERATE_MODIFY_NAME, FILE_TYPE_SICFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGFREQBANDINDICATOR:
                table_entry->old_protocolCommConfigFreqBandIndicator =
                    table_entry->protocolCommConfigFreqBandIndicator;
                table_entry->protocolCommConfigFreqBandIndicator =
                    *request->requestvb->val.integer;

                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);
                if (docpath)
                {
                	ret = modify_cfg_file(docpath, SICfg_freqBandIndicator, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGDLCARRIERFREQ:
                table_entry->old_protocolCommConfigDLCarrierFreq =
                    table_entry->protocolCommConfigDLCarrierFreq;
                table_entry->protocolCommConfigDLCarrierFreq =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);

                if (docpath)
                {
                     ret = modify_cfg_file(docpath, SICfg_dl_CarrierFreq, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
                     ret = modify_cfg_file(docpath, Cfg_earfcn_dl, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGULCARRIERFREQ:
                table_entry->old_protocolCommConfigULCarrierFreq =
                    table_entry->protocolCommConfigULCarrierFreq;
                table_entry->protocolCommConfigULCarrierFreq =
                    *request->requestvb->val.integer;

                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);

                if (docpath)
                {
                     ret = modify_cfg_file(docpath, SICfg_ul_CarrierFreq, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
                     ret = modify_cfg_file(docpath, Cfg_earfcn_ul, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSUBFRAMEASSIGNMENT:
                memcpy(table_entry->
                       old_protocolCommConfigSubFrameAssignment,
                       table_entry->protocolCommConfigSubFrameAssignment,
                       sizeof(table_entry->
                              protocolCommConfigSubFrameAssignment));
                table_entry->old_protocolCommConfigSubFrameAssignment_len =
                    table_entry->protocolCommConfigSubFrameAssignment_len;
                memset(table_entry->protocolCommConfigSubFrameAssignment,
                       0,
                       sizeof(table_entry->
                              protocolCommConfigSubFrameAssignment));
                memcpy(table_entry->protocolCommConfigSubFrameAssignment,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigSubFrameAssignment_len =
                    request->requestvb->val_len;

                if (docpath)
                {
                	ret = modify_cfg_file(docpath, SICfg_subframeAssign, table_entry->protocolCommConfigSubFrameAssignment, OPERATE_MODIFY_NAME, FILE_TYPE_SICFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSPECIALSUBFRAMEPAT:
                memcpy(table_entry->
                       old_protocolCommConfigSpecialSubFramePat,
                       table_entry->protocolCommConfigSpecialSubFramePat,
                       sizeof(table_entry->
                              protocolCommConfigSpecialSubFramePat));
                table_entry->old_protocolCommConfigSpecialSubFramePat_len =
                    table_entry->protocolCommConfigSpecialSubFramePat_len;
                memset(table_entry->protocolCommConfigSpecialSubFramePat,
                       0,
                       sizeof(table_entry->
                              protocolCommConfigSpecialSubFramePat));
                memcpy(table_entry->protocolCommConfigSpecialSubFramePat,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigSpecialSubFramePat_len =
                    request->requestvb->val_len;

                if (docpath)
                {
                	ret = modify_cfg_file(docpath, SICfg_speSubPatterns, table_entry->protocolCommConfigSpecialSubFramePat, OPERATE_MODIFY_NAME, FILE_TYPE_SICFG );
                }


                break;
            case COLUMN_PROTOCOLCOMMCONFIGPHYCELLID:
                table_entry->old_protocolCommConfigPhyCellID =
                    table_entry->protocolCommConfigPhyCellID;
                table_entry->protocolCommConfigPhyCellID =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);
                if (docpath)
                {
                     ret = modify_cfg_file(docpath, Cfg_phy_cell_id, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGTXANTPORT:
                table_entry->old_protocolCommConfigTxAntPort =
                    table_entry->protocolCommConfigTxAntPort;
                table_entry->protocolCommConfigTxAntPort =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, Cfg_tx_ant_port, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGRXANTPORT:
                table_entry->old_protocolCommConfigRxAntPort =
                    table_entry->protocolCommConfigRxAntPort;
                table_entry->protocolCommConfigRxAntPort =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, Cfg_rx_ant_port, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGPLMDID:
                memcpy(table_entry->old_protocolCommConfigPlmdID,
                       table_entry->protocolCommConfigPlmdID,
                       sizeof(table_entry->protocolCommConfigPlmdID));
                table_entry->old_protocolCommConfigPlmdID_len =
                    table_entry->protocolCommConfigPlmdID_len;
                memset(table_entry->protocolCommConfigPlmdID, 0,
                       sizeof(table_entry->protocolCommConfigPlmdID));
                memcpy(table_entry->protocolCommConfigPlmdID,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigPlmdID_len =
                    request->requestvb->val_len;



                if (docpath)
                {
                     ret = modify_cfg_file(docpath, Cfg_plmn_id, table_entry->protocolCommConfigPlmdID, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                     for(i = 0; i<5 ; i++)
                     {
                         memset(table_info_int_value,0,sizeof(table_info_int_value));
                         memcpy(table_info_int_value, table_entry->protocolCommConfigPlmdID+i,1);
                         table_info_int_value[1]='\0';
                         if (i < 3)
                         {
                        	 ret = modify_cfg_file(docpath, SICfg_plmnid, table_info_int_value, OPERATE_MODIFY_VALUE_NEXT, FILE_TYPE_SICFG , i);
                         }
                         else
                         {
                        	 ret = modify_cfg_file(docpath, SICfg_plmnid_more, table_info_int_value, OPERATE_MODIFY_VALUE_NEXT, FILE_TYPE_SICFG , i-3);
                         }

                     }
                }


                break;
            case COLUMN_PROTOCOLCOMMCONFIGTRACKINGAREACODE:
                memcpy(table_entry->old_protocolCommConfigTrackingAreaCode,
                       table_entry->protocolCommConfigTrackingAreaCode,
                       sizeof(table_entry->
                              protocolCommConfigTrackingAreaCode));
                table_entry->old_protocolCommConfigTrackingAreaCode_len =
                    table_entry->protocolCommConfigTrackingAreaCode_len;
                memset(table_entry->protocolCommConfigTrackingAreaCode, 0,
                       sizeof(table_entry->
                              protocolCommConfigTrackingAreaCode));
                memcpy(table_entry->protocolCommConfigTrackingAreaCode,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolCommConfigTrackingAreaCode_len =
                    request->requestvb->val_len;
				if (docpath)
				{
				    ret = modify_cfg_file(docpath, SICfg_trackingAreaCode, table_entry->protocolCommConfigTrackingAreaCode, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
				}
                break;
            case COLUMN_PROTOCOLCOMMCONFIGROWSTATUS:
                    table_entry->old_protocolCommConfigRowStatus =
                        table_entry->protocolCommConfigRowStatus;
                    table_entry->protocolCommConfigRowStatus =
                        *request->requestvb->val.integer;


                if (RS_DESTROY == *request->requestvb->val.integer)
                {
                	protocolCommConfigTable_removeEntry (table_entry);
                	memset(cfg_dic,0,sizeof(cfg_dic));
        			char *procfgdic = generate_protocol_dic(cfg_dic,*table_info->indexes->val.integer);
        			if ( g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic != NULL || strcmp(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic, procfgdic) == 0)
        			{
        				ret = remove_protocol_docu(procfgdic);
        				memset(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic,0,STR_LEN_256);
        			}

                }
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolCommConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLCOMMCONFIGENODEBID:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigeNodebID =
                        table_entry->old_protocolCommConfigeNodebID;
                    table_entry->old_protocolCommConfigeNodebID = 0;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGENODEBIP:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolCommConfigeNodebIP,
                           table_entry->old_protocolCommConfigeNodebIP,
                           sizeof(table_entry->
                                  protocolCommConfigeNodebIP));
                    memset(table_entry->old_protocolCommConfigeNodebIP, 0,
                           sizeof(table_entry->
                                  protocolCommConfigeNodebIP));
                    table_entry->protocolCommConfigeNodebIP_len =
                        table_entry->old_protocolCommConfigeNodebIP_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGMMEIPADDR:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolCommConfigMMEIPAddr,
                           table_entry->old_protocolCommConfigMMEIPAddr,
                           sizeof(table_entry->
                                  protocolCommConfigMMEIPAddr));
                    memset(table_entry->old_protocolCommConfigMMEIPAddr, 0,
                           sizeof(table_entry->
                                  protocolCommConfigMMEIPAddr));
                    table_entry->protocolCommConfigMMEIPAddr_len =
                        table_entry->old_protocolCommConfigMMEIPAddr_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSGWIPADDR:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolCommConfigSGWIPAddr,
                           table_entry->old_protocolCommConfigSGWIPAddr,
                           sizeof(table_entry->
                                  protocolCommConfigSGWIPAddr));
                    memset(table_entry->old_protocolCommConfigSGWIPAddr, 0,
                           sizeof(table_entry->
                                  protocolCommConfigSGWIPAddr));
                    table_entry->protocolCommConfigSGWIPAddr_len =
                        table_entry->old_protocolCommConfigSGWIPAddr_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGFTPIP:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolCommConfigFTPIP,
                           table_entry->old_protocolCommConfigFTPIP,
                           sizeof(table_entry->protocolCommConfigFTPIP));
                    memset(table_entry->old_protocolCommConfigFTPIP, 0,
                           sizeof(table_entry->protocolCommConfigFTPIP));
                    table_entry->protocolCommConfigFTPIP_len =
                        table_entry->old_protocolCommConfigFTPIP_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGCELLIDENTITY:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigCellIdentity =
                        table_entry->old_protocolCommConfigCellIdentity;
                    table_entry->old_protocolCommConfigCellIdentity = 0;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGVBSID:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigVBSID =
                        table_entry->old_protocolCommConfigVBSID;
                    table_entry->old_protocolCommConfigVBSID = 0;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGVBSMODE:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolCommConfigVBSMode,
                           table_entry->old_protocolCommConfigVBSMode,
                           sizeof(table_entry->protocolCommConfigVBSMode));
                    memset(table_entry->old_protocolCommConfigVBSMode, 0,
                           sizeof(table_entry->protocolCommConfigVBSMode));
                    table_entry->protocolCommConfigVBSMode_len =
                        table_entry->old_protocolCommConfigVBSMode_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGDLBANDWIDTH:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolCommConfigDLBandwidth,
                           table_entry->old_protocolCommConfigDLBandwidth,
                           sizeof(table_entry->
                                  protocolCommConfigDLBandwidth));
                    memset(table_entry->old_protocolCommConfigDLBandwidth,
                           0,
                           sizeof(table_entry->
                                  protocolCommConfigDLBandwidth));
                    table_entry->protocolCommConfigDLBandwidth_len =
                        table_entry->old_protocolCommConfigDLBandwidth_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGULBANDWIDTH:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolCommConfigULBandwidth,
                           table_entry->old_protocolCommConfigULBandwidth,
                           sizeof(table_entry->
                                  protocolCommConfigULBandwidth));
                    memset(table_entry->old_protocolCommConfigULBandwidth,
                           0,
                           sizeof(table_entry->
                                  protocolCommConfigULBandwidth));
                    table_entry->protocolCommConfigULBandwidth_len =
                        table_entry->old_protocolCommConfigULBandwidth_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGFREQBANDINDICATOR:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigFreqBandIndicator =
                        table_entry->
                        old_protocolCommConfigFreqBandIndicator;
                    table_entry->old_protocolCommConfigFreqBandIndicator =
                        0;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGDLCARRIERFREQ:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigDLCarrierFreq =
                        table_entry->old_protocolCommConfigDLCarrierFreq;
                    table_entry->old_protocolCommConfigDLCarrierFreq = 0;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGULCARRIERFREQ:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigULCarrierFreq =
                        table_entry->old_protocolCommConfigULCarrierFreq;
                    table_entry->old_protocolCommConfigULCarrierFreq = 0;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSUBFRAMEASSIGNMENT:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->
                           protocolCommConfigSubFrameAssignment,
                           table_entry->
                           old_protocolCommConfigSubFrameAssignment,
                           sizeof(table_entry->
                                  protocolCommConfigSubFrameAssignment));
                    memset(table_entry->
                           old_protocolCommConfigSubFrameAssignment, 0,
                           sizeof(table_entry->
                                  protocolCommConfigSubFrameAssignment));
                    table_entry->protocolCommConfigSubFrameAssignment_len =
                        table_entry->
                        old_protocolCommConfigSubFrameAssignment_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGSPECIALSUBFRAMEPAT:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->
                           protocolCommConfigSpecialSubFramePat,
                           table_entry->
                           old_protocolCommConfigSpecialSubFramePat,
                           sizeof(table_entry->
                                  protocolCommConfigSpecialSubFramePat));
                    memset(table_entry->
                           old_protocolCommConfigSpecialSubFramePat, 0,
                           sizeof(table_entry->
                                  protocolCommConfigSpecialSubFramePat));
                    table_entry->protocolCommConfigSpecialSubFramePat_len =
                        table_entry->
                        old_protocolCommConfigSpecialSubFramePat_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGPHYCELLID:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigPhyCellID =
                        table_entry->old_protocolCommConfigPhyCellID;
                    table_entry->old_protocolCommConfigPhyCellID = 0;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGTXANTPORT:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigTxAntPort =
                        table_entry->old_protocolCommConfigTxAntPort;
                    table_entry->old_protocolCommConfigTxAntPort = 0;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGRXANTPORT:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigRxAntPort =
                        table_entry->old_protocolCommConfigRxAntPort;
                    table_entry->old_protocolCommConfigRxAntPort = 0;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGPLMDID:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolCommConfigPlmdID,
                           table_entry->old_protocolCommConfigPlmdID,
                           sizeof(table_entry->protocolCommConfigPlmdID));
                    memset(table_entry->old_protocolCommConfigPlmdID, 0,
                           sizeof(table_entry->protocolCommConfigPlmdID));
                    table_entry->protocolCommConfigPlmdID_len =
                        table_entry->old_protocolCommConfigPlmdID_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGTRACKINGAREACODE:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolCommConfigTrackingAreaCode,
                           table_entry->
                           old_protocolCommConfigTrackingAreaCode,
                           sizeof(table_entry->
                                  protocolCommConfigTrackingAreaCode));
                    memset(table_entry->
                           old_protocolCommConfigTrackingAreaCode, 0,
                           sizeof(table_entry->
                                  protocolCommConfigTrackingAreaCode));
                    table_entry->protocolCommConfigTrackingAreaCode_len =
                        table_entry->
                        old_protocolCommConfigTrackingAreaCode_len;
                }
                break;
            case COLUMN_PROTOCOLCOMMCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    protocolCommConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolCommConfigRowStatus =
                        table_entry->old_protocolCommConfigRowStatus;
                    table_entry->old_protocolCommConfigRowStatus = 0;
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolCommConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLCOMMCONFIGENODEBID:
            case COLUMN_PROTOCOLCOMMCONFIGENODEBIP:
            case COLUMN_PROTOCOLCOMMCONFIGMMEIPADDR:
            case COLUMN_PROTOCOLCOMMCONFIGSGWIPADDR:
            case COLUMN_PROTOCOLCOMMCONFIGFTPIP:
            case COLUMN_PROTOCOLCOMMCONFIGCELLIDENTITY:
            case COLUMN_PROTOCOLCOMMCONFIGVBSID:
            case COLUMN_PROTOCOLCOMMCONFIGVBSMODE:
            case COLUMN_PROTOCOLCOMMCONFIGDLBANDWIDTH:
            case COLUMN_PROTOCOLCOMMCONFIGULBANDWIDTH:
            case COLUMN_PROTOCOLCOMMCONFIGFREQBANDINDICATOR:
            case COLUMN_PROTOCOLCOMMCONFIGDLCARRIERFREQ:
            case COLUMN_PROTOCOLCOMMCONFIGULCARRIERFREQ:
            case COLUMN_PROTOCOLCOMMCONFIGSUBFRAMEASSIGNMENT:
            case COLUMN_PROTOCOLCOMMCONFIGSPECIALSUBFRAMEPAT:
            case COLUMN_PROTOCOLCOMMCONFIGPHYCELLID:
            case COLUMN_PROTOCOLCOMMCONFIGTXANTPORT:
            case COLUMN_PROTOCOLCOMMCONFIGRXANTPORT:
            case COLUMN_PROTOCOLCOMMCONFIGPLMDID:
            case COLUMN_PROTOCOLCOMMCONFIGTRACKINGAREACODE:
            case COLUMN_PROTOCOLCOMMCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    table_entry->valid = 1;
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}


/** Initialize the protocolAccessConfigTable table by defining its contents and how it's structured */
void
initialize_table_protocolAccessConfigTable(void)
{
    const oid       protocolAccessConfigTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 2 };
    const size_t    protocolAccessConfigTable_oid_len =
        OID_LENGTH(protocolAccessConfigTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("protocolCommConfigInfo:init",
                "initializing table protocolAccessConfigTable\n"));

    reg =
        netsnmp_create_handler_registration("protocolAccessConfigTable",
                                            protocolAccessConfigTable_handler,
                                            protocolAccessConfigTable_oid,
                                            protocolAccessConfigTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: protocolAccessConfigIndex */
                                     0);
    table_info->min_column = COLUMN_PROTOCOLACCESSCONFIGNUMOFRAPREAMBLES;
    table_info->max_column = COLUMN_PROTOCOLACCESSCONFIGROWSTATUS;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point =
        protocolAccessConfigTable_get_first_data_point;
    iinfo->get_next_data_point =
        protocolAccessConfigTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    /*
     * Initialise the contents of the table here 
     */
}




/*
 * create a new row in the (unsorted) table 
 */
struct protocolAccessConfigTable_entry *
protocolAccessConfigTable_createEntry(u_long protocolAccessConfigIndex)
{
    struct protocolAccessConfigTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct protocolAccessConfigTable_entry);
    if (!entry)
        return NULL;

    entry->protocolAccessConfigIndex = protocolAccessConfigIndex;
    entry->next = protocolAccessConfigTable_head;
    protocolAccessConfigTable_head = entry;
    return entry;
}

/*
 * remove a row from the table 
 */
void
protocolAccessConfigTable_removeEntry(struct
                                      protocolAccessConfigTable_entry
                                      *entry)
{
    struct protocolAccessConfigTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = protocolAccessConfigTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        protocolAccessConfigTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}


/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
protocolAccessConfigTable_get_first_data_point(void **my_loop_context,
                                               void **my_data_context,
                                               netsnmp_variable_list *
                                               put_index_data,
                                               netsnmp_iterator_info
                                               *mydata)
{
    *my_loop_context = protocolAccessConfigTable_head;
    return protocolAccessConfigTable_get_next_data_point(my_loop_context,
                                                         my_data_context,
                                                         put_index_data,
                                                         mydata);
}

netsnmp_variable_list *
protocolAccessConfigTable_get_next_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
    struct protocolAccessConfigTable_entry *entry =
        (struct protocolAccessConfigTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_UNSIGNED,
                                   entry->protocolAccessConfigIndex);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the protocolAccessConfigTable table */
int
protocolAccessConfigTable_handler(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct protocolAccessConfigTable_entry *table_entry;
    struct protocolAccessConfigTable_entry *table_row;

    DEBUGMSGTL(("protocolCommConfigInfo:handler",
                "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolAccessConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLACCESSCONFIGNUMOFRAPREAMBLES:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolAccessConfigNumOFRAPreambles,
                                         table_entry->
                                         protocolAccessConfigNumOFRAPreambles_len);
                break;
            case COLUMN_PROTOCOLACCESSCONFIGSIZEOFRAGROUPA:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolAccessConfigSizeOfRAGroupA,
                                         table_entry->
                                         protocolAccessConfigSizeOfRAGroupA_len);
                break;
            case COLUMN_PROTOCOLACCESSCONFIGPREAMBLETRANSMAX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolAccessConfigPreambleTransMax,
                                         table_entry->
                                         protocolAccessConfigPreambleTransMax_len);
                break;
            case COLUMN_PROTOCOLACCESSCONFIGMAXHARQMSG3TX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb,
                                           ASN_UNSIGNED,
                                           table_entry->
                                           protocolAccessConfigMaxHARQMsg3Tx);
                break;
            case COLUMN_PROTOCOLACCESSCONFIGROWSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           protocolAccessConfigRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolAccessConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLACCESSCONFIGNUMOFRAPREAMBLES:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolAccessConfigNumOFRAPreambles));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLACCESSCONFIGSIZEOFRAGROUPA:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolAccessConfigSizeOfRAGroupA));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLACCESSCONFIGPREAMBLETRANSMAX:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolAccessConfigPreambleTransMax));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLACCESSCONFIGMAXHARQMSG3TX:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLACCESSCONFIGROWSTATUS:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolAccessConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLACCESSCONFIGNUMOFRAPREAMBLES:
            case COLUMN_PROTOCOLACCESSCONFIGSIZEOFRAGROUPA:
            case COLUMN_PROTOCOLACCESSCONFIGPREAMBLETRANSMAX:
            case COLUMN_PROTOCOLACCESSCONFIGMAXHARQMSG3TX:
            case COLUMN_PROTOCOLACCESSCONFIGROWSTATUS:
            	switch (*request->requestvb->val.integer){
            	    case RS_CREATEANDGO:
            	    case RS_CREATEANDWAIT:
            	        table_row = protocolAccessConfigTable_createEntry(*table_info->indexes->val.integer);
            	        if (table_row){
            	            netsnmp_insert_iterator_context(request,table_row);

            	            //generate a new file
            	            char *procfgdic = generate_protocol_dic(cfg_dic,*table_info->indexes->val.integer);
                			if ( g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic == NULL || strcmp(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic, procfgdic) != 0)
                			{
                	            ret = generate_protocol_docu(PROTOCOL_CFG_DEFAULT, procfgdic);
                	            memcpy(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic,procfgdic,sizeof(char)*256);
                			}


            	        }
            	        else{
            	            netsnmp_set_request_error(reqinfo, request,SNMP_ERR_RESOURCEUNAVAILABLE);
            	            return SNMP_ERR_NOERROR;
            	        }
            	        break;
            	 }
                break;
            }
        }
        break;

    case MODE_SET_FREE:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolAccessConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLACCESSCONFIGNUMOFRAPREAMBLES:
            case COLUMN_PROTOCOLACCESSCONFIGSIZEOFRAGROUPA:
            case COLUMN_PROTOCOLACCESSCONFIGPREAMBLETRANSMAX:
            case COLUMN_PROTOCOLACCESSCONFIGMAXHARQMSG3TX:
            case COLUMN_PROTOCOLACCESSCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    protocolAccessConfigTable_removeEntry(table_row);
                }
                break;
            }
        }
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolAccessConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
            char *docpath = g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic;

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLACCESSCONFIGNUMOFRAPREAMBLES:
                memcpy(table_entry->
                       old_protocolAccessConfigNumOFRAPreambles,
                       table_entry->protocolAccessConfigNumOFRAPreambles,
                       sizeof(table_entry->
                              protocolAccessConfigNumOFRAPreambles));
                table_entry->old_protocolAccessConfigNumOFRAPreambles_len =
                    table_entry->protocolAccessConfigNumOFRAPreambles_len;
                memset(table_entry->protocolAccessConfigNumOFRAPreambles,
                       0,
                       sizeof(table_entry->
                              protocolAccessConfigNumOFRAPreambles));
                memcpy(table_entry->protocolAccessConfigNumOFRAPreambles,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolAccessConfigNumOFRAPreambles_len =
                    request->requestvb->val_len;
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, SICfg_numberOfRA_Preambles, table_entry->protocolAccessConfigNumOFRAPreambles, OPERATE_MODIFY_NAME, FILE_TYPE_SICFG );
                }

                break;
            case COLUMN_PROTOCOLACCESSCONFIGSIZEOFRAGROUPA:
                memcpy(table_entry->old_protocolAccessConfigSizeOfRAGroupA,
                       table_entry->protocolAccessConfigSizeOfRAGroupA,
                       sizeof(table_entry->
                              protocolAccessConfigSizeOfRAGroupA));
                table_entry->old_protocolAccessConfigSizeOfRAGroupA_len =
                    table_entry->protocolAccessConfigSizeOfRAGroupA_len;
                memset(table_entry->protocolAccessConfigSizeOfRAGroupA, 0,
                       sizeof(table_entry->
                              protocolAccessConfigSizeOfRAGroupA));
                memcpy(table_entry->protocolAccessConfigSizeOfRAGroupA,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolAccessConfigSizeOfRAGroupA_len =
                    request->requestvb->val_len;


                break;
            case COLUMN_PROTOCOLACCESSCONFIGPREAMBLETRANSMAX:
                memcpy(table_entry->
                       old_protocolAccessConfigPreambleTransMax,
                       table_entry->protocolAccessConfigPreambleTransMax,
                       sizeof(table_entry->
                              protocolAccessConfigPreambleTransMax));
                table_entry->old_protocolAccessConfigPreambleTransMax_len =
                    table_entry->protocolAccessConfigPreambleTransMax_len;
                memset(table_entry->protocolAccessConfigPreambleTransMax,
                       0,
                       sizeof(table_entry->
                              protocolAccessConfigPreambleTransMax));
                memcpy(table_entry->protocolAccessConfigPreambleTransMax,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolAccessConfigPreambleTransMax_len =
                    request->requestvb->val_len;

				if (docpath)
				{
				     ret = modify_cfg_file(docpath, SICfg_preambleTransMax, table_entry->protocolAccessConfigPreambleTransMax, OPERATE_MODIFY_NAME, FILE_TYPE_SICFG );
				}


                break;
            case COLUMN_PROTOCOLACCESSCONFIGMAXHARQMSG3TX:
                table_entry->old_protocolAccessConfigMaxHARQMsg3Tx =
                    table_entry->protocolAccessConfigMaxHARQMsg3Tx;
                table_entry->protocolAccessConfigMaxHARQMsg3Tx =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);

				if (docpath)
				{
				     ret = modify_cfg_file(docpath, SICfg_maxHARQ_Msg3Tx, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
				}
                break;
            case COLUMN_PROTOCOLACCESSCONFIGROWSTATUS:
                table_entry->old_protocolAccessConfigRowStatus =
                    table_entry->protocolAccessConfigRowStatus;
                table_entry->protocolAccessConfigRowStatus =
                    *request->requestvb->val.integer;
                if (RS_DESTROY == table_entry->protocolAccessConfigRowStatus)
                {
                	protocolAccessConfigTable_removeEntry (table_entry);
                	memset(cfg_dic,0,sizeof(cfg_dic));
        			char *procfgdic = generate_protocol_dic(cfg_dic,*table_info->indexes->val.integer);
        			if ( g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic != NULL || strcmp(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic, procfgdic) == 0)
        			{
        				ret = remove_protocol_docu(procfgdic);
        				memset(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic,0,STR_LEN_256);
        			}

                }
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolAccessConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLACCESSCONFIGNUMOFRAPREAMBLES:
                if (table_entry && !table_entry->valid) {
                    protocolAccessConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->
                           protocolAccessConfigNumOFRAPreambles,
                           table_entry->
                           old_protocolAccessConfigNumOFRAPreambles,
                           sizeof(table_entry->
                                  protocolAccessConfigNumOFRAPreambles));
                    memset(table_entry->
                           old_protocolAccessConfigNumOFRAPreambles, 0,
                           sizeof(table_entry->
                                  protocolAccessConfigNumOFRAPreambles));
                    table_entry->protocolAccessConfigNumOFRAPreambles_len =
                        table_entry->
                        old_protocolAccessConfigNumOFRAPreambles_len;
                }
                break;
            case COLUMN_PROTOCOLACCESSCONFIGSIZEOFRAGROUPA:
                if (table_entry && !table_entry->valid) {
                    protocolAccessConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolAccessConfigSizeOfRAGroupA,
                           table_entry->
                           old_protocolAccessConfigSizeOfRAGroupA,
                           sizeof(table_entry->
                                  protocolAccessConfigSizeOfRAGroupA));
                    memset(table_entry->
                           old_protocolAccessConfigSizeOfRAGroupA, 0,
                           sizeof(table_entry->
                                  protocolAccessConfigSizeOfRAGroupA));
                    table_entry->protocolAccessConfigSizeOfRAGroupA_len =
                        table_entry->
                        old_protocolAccessConfigSizeOfRAGroupA_len;
                }
                break;
            case COLUMN_PROTOCOLACCESSCONFIGPREAMBLETRANSMAX:
                if (table_entry && !table_entry->valid) {
                    protocolAccessConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->
                           protocolAccessConfigPreambleTransMax,
                           table_entry->
                           old_protocolAccessConfigPreambleTransMax,
                           sizeof(table_entry->
                                  protocolAccessConfigPreambleTransMax));
                    memset(table_entry->
                           old_protocolAccessConfigPreambleTransMax, 0,
                           sizeof(table_entry->
                                  protocolAccessConfigPreambleTransMax));
                    table_entry->protocolAccessConfigPreambleTransMax_len =
                        table_entry->
                        old_protocolAccessConfigPreambleTransMax_len;
                }
                break;
            case COLUMN_PROTOCOLACCESSCONFIGMAXHARQMSG3TX:
                if (table_entry && !table_entry->valid) {
                    protocolAccessConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolAccessConfigMaxHARQMsg3Tx =
                        table_entry->old_protocolAccessConfigMaxHARQMsg3Tx;
                    table_entry->old_protocolAccessConfigMaxHARQMsg3Tx = 0;
                }
                break;
            case COLUMN_PROTOCOLACCESSCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    protocolAccessConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolAccessConfigRowStatus =
                        table_entry->old_protocolAccessConfigRowStatus;
                    table_entry->old_protocolAccessConfigRowStatus = 0;
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolAccessConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLACCESSCONFIGNUMOFRAPREAMBLES:
            case COLUMN_PROTOCOLACCESSCONFIGSIZEOFRAGROUPA:
            case COLUMN_PROTOCOLACCESSCONFIGPREAMBLETRANSMAX:
            case COLUMN_PROTOCOLACCESSCONFIGMAXHARQMSG3TX:
            case COLUMN_PROTOCOLACCESSCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    table_entry->valid = 1;
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}


/** Initialize the protocolPowerConfigTable table by defining its contents and how it's structured */
void
initialize_table_protocolPowerConfigTable(void)
{
    const oid       protocolPowerConfigTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 3 };
    const size_t    protocolPowerConfigTable_oid_len =
        OID_LENGTH(protocolPowerConfigTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("protocolCommConfigInfo:init",
                "initializing table protocolPowerConfigTable\n"));

    reg =
        netsnmp_create_handler_registration("protocolPowerConfigTable",
                                            protocolPowerConfigTable_handler,
                                            protocolPowerConfigTable_oid,
                                            protocolPowerConfigTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: protocolPowerConfigIndex */
                                     0);
    table_info->min_column = COLUMN_PROTOCOLPOWERCONFIGQRXLEVMIN;
    table_info->max_column = COLUMN_PROTOCOLPOWERCONFIGROWSTATUS;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point =
        protocolPowerConfigTable_get_first_data_point;
    iinfo->get_next_data_point =
        protocolPowerConfigTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    /*
     * Initialise the contents of the table here 
     */
}

    /*
     * Typical data structure for a row entry 
     */



/*
 * create a new row in the (unsorted) table 
 */
struct protocolPowerConfigTable_entry *
protocolPowerConfigTable_createEntry(u_long protocolPowerConfigIndex)
{
    struct protocolPowerConfigTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct protocolPowerConfigTable_entry);
    if (!entry)
        return NULL;

    entry->protocolPowerConfigIndex = protocolPowerConfigIndex;
    entry->next = protocolPowerConfigTable_head;
    protocolPowerConfigTable_head = entry;
    return entry;
}

/*
 * remove a row from the table 
 */
void
protocolPowerConfigTable_removeEntry(struct protocolPowerConfigTable_entry
                                     *entry)
{
    struct protocolPowerConfigTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = protocolPowerConfigTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        protocolPowerConfigTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}


/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
protocolPowerConfigTable_get_first_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
    *my_loop_context = protocolPowerConfigTable_head;
    return protocolPowerConfigTable_get_next_data_point(my_loop_context,
                                                        my_data_context,
                                                        put_index_data,
                                                        mydata);
}

netsnmp_variable_list *
protocolPowerConfigTable_get_next_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
    struct protocolPowerConfigTable_entry *entry =
        (struct protocolPowerConfigTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_UNSIGNED,
                                   entry->protocolPowerConfigIndex);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the protocolPowerConfigTable table */
int
protocolPowerConfigTable_handler(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct protocolPowerConfigTable_entry *table_entry;
    struct protocolPowerConfigTable_entry *table_row;
    DEBUGMSGTL(("protocolCommConfigInfo:handler",
                "Processing request (%d)\n", reqinfo->mode));
    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolPowerConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLPOWERCONFIGQRXLEVMIN:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           protocolPowerConfigQRxLevMin);
                break;
            case COLUMN_PROTOCOLPOWERCONFIGPMAX:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           protocolPowerConfigPMax);
                break;
            case COLUMN_PROTOCOLPOWERCONFIGPINITRECVTARPOWER:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolPowerConfigPInitRecvTarPower,
                                         table_entry->
                                         protocolPowerConfigPInitRecvTarPower_len);
                break;
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMINALPUSCH:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           protocolPowerConfigP0NominalPUSCH);
                break;
            case COLUMN_PROTOCOLPOWERCONFIGALPHA:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolPowerConfigAlpha,
                                         table_entry->
                                         protocolPowerConfigAlpha_len);
                break;
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMIPUCCH:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           protocolPowerConfigP0NomiPUCCH);
                break;
            case COLUMN_PROTOCOLPOWERCONFIGROWSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           protocolPowerConfigRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolPowerConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLPOWERCONFIGQRXLEVMIN:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGPMAX:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGPINITRECVTARPOWER:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolPowerConfigPInitRecvTarPower));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMINALPUSCH:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGALPHA:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolPowerConfigAlpha));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMIPUCCH:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGROWSTATUS:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolPowerConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLPOWERCONFIGQRXLEVMIN:
            case COLUMN_PROTOCOLPOWERCONFIGPMAX:
            case COLUMN_PROTOCOLPOWERCONFIGPINITRECVTARPOWER:
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMINALPUSCH:
            case COLUMN_PROTOCOLPOWERCONFIGALPHA:
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMIPUCCH:
            case COLUMN_PROTOCOLPOWERCONFIGROWSTATUS:
            	switch (*request->requestvb->val.integer){
    	            case RS_CREATEANDGO:
    	            case RS_CREATEANDWAIT:
    	            table_row = protocolPowerConfigTable_createEntry(*table_info->indexes->val.integer);
    	            if (table_row){
    	            netsnmp_insert_iterator_context(request,table_row);

    	            //generate a new file
    	            char *procfgdic = generate_protocol_dic(cfg_dic,*table_info->indexes->val.integer);
        			if ( g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic == NULL || strcmp(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic, procfgdic) != 0)
        			{
        	            ret = generate_protocol_docu(PROTOCOL_CFG_DEFAULT, procfgdic);
        	            memcpy(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic,procfgdic,sizeof(char)*256);
        			}


    	            }
    	            else{
    	                netsnmp_set_request_error(reqinfo, request,SNMP_ERR_RESOURCEUNAVAILABLE);
    	                return SNMP_ERR_NOERROR;
    	            }
            	}
    	        break;
            }
        }
        break;

    case MODE_SET_FREE:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolPowerConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLPOWERCONFIGQRXLEVMIN:
            case COLUMN_PROTOCOLPOWERCONFIGPMAX:
            case COLUMN_PROTOCOLPOWERCONFIGPINITRECVTARPOWER:
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMINALPUSCH:
            case COLUMN_PROTOCOLPOWERCONFIGALPHA:
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMIPUCCH:
            case COLUMN_PROTOCOLPOWERCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    protocolPowerConfigTable_removeEntry(table_row);
                }
                break;
            }
        }
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolPowerConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
            char *docpath = g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic;
            switch (table_info->colnum) {
            case COLUMN_PROTOCOLPOWERCONFIGQRXLEVMIN:
                table_entry->old_protocolPowerConfigQRxLevMin =
                    table_entry->protocolPowerConfigQRxLevMin;
                table_entry->protocolPowerConfigQRxLevMin =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);


                if (docpath)
                {
                	ret = modify_cfg_file(docpath, SICfg_q_RxLevMin, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGPMAX:
                table_entry->old_protocolPowerConfigPMax =
                    table_entry->protocolPowerConfigPMax;
                table_entry->protocolPowerConfigPMax =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);

                if (docpath)
                {
                    ret = modify_cfg_file(docpath, SICfg_p_Max,table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGPINITRECVTARPOWER:
                memcpy(table_entry->
                       old_protocolPowerConfigPInitRecvTarPower,
                       table_entry->protocolPowerConfigPInitRecvTarPower,
                       sizeof(table_entry->
                              protocolPowerConfigPInitRecvTarPower));
                table_entry->old_protocolPowerConfigPInitRecvTarPower_len =
                    table_entry->protocolPowerConfigPInitRecvTarPower_len;
                memset(table_entry->protocolPowerConfigPInitRecvTarPower,
                       0,
                       sizeof(table_entry->
                              protocolPowerConfigPInitRecvTarPower));
                memcpy(table_entry->protocolPowerConfigPInitRecvTarPower,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolPowerConfigPInitRecvTarPower_len =
                    request->requestvb->val_len;
                //printf("begin modify the node");
				if (docpath)
				{
				    ret = modify_cfg_file(docpath, SICfg_preambleInitialReceivedTargetPower, table_entry->protocolPowerConfigPInitRecvTarPower, OPERATE_MODIFY_NAME_NEXT, FILE_TYPE_SICFG);
				}
                break;
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMINALPUSCH:
                table_entry->old_protocolPowerConfigP0NominalPUSCH =
                    table_entry->protocolPowerConfigP0NominalPUSCH;
                table_entry->protocolPowerConfigP0NominalPUSCH =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);

				if (docpath)
				{
					ret = modify_cfg_file(docpath, SICfg_p0_NominalPUSCH, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
				}
                break;
            case COLUMN_PROTOCOLPOWERCONFIGALPHA:
                memcpy(table_entry->old_protocolPowerConfigAlpha,
                       table_entry->protocolPowerConfigAlpha,
                       sizeof(table_entry->protocolPowerConfigAlpha));
                table_entry->old_protocolPowerConfigAlpha_len =
                    table_entry->protocolPowerConfigAlpha_len;
                memset(table_entry->protocolPowerConfigAlpha, 0,
                       sizeof(table_entry->protocolPowerConfigAlpha));
                memcpy(table_entry->protocolPowerConfigAlpha,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolPowerConfigAlpha_len =
                    request->requestvb->val_len;
				if (docpath)
				{
					ret = modify_cfg_file(docpath, SICfg_alpha, table_entry->protocolPowerConfigAlpha, OPERATE_MODIFY_NAME, FILE_TYPE_SICFG );
				}
                break;
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMIPUCCH:
                table_entry->old_protocolPowerConfigP0NomiPUCCH =
                    table_entry->protocolPowerConfigP0NomiPUCCH;
                table_entry->protocolPowerConfigP0NomiPUCCH =
                    *request->requestvb->val.integer;
                memset(table_info_int_value,0,sizeof(table_info_int_value));
                sprintf(table_info_int_value, "%d",*request->requestvb->val.integer);

                if (docpath)
                {
                	ret = modify_cfg_file(docpath, SICfg_p0_NominalPUCCH, table_info_int_value, OPERATE_MODIFY_VALUE, FILE_TYPE_SICFG );
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGROWSTATUS:
                table_entry->old_protocolPowerConfigRowStatus =
                    table_entry->protocolPowerConfigRowStatus;
                table_entry->protocolPowerConfigRowStatus =
                    *request->requestvb->val.integer;
                if (RS_DESTROY == table_entry->protocolPowerConfigRowStatus)
                {
                	protocolPowerConfigTable_removeEntry (table_entry);
                	memset(cfg_dic,0,sizeof(cfg_dic));
        			char *procfgdic = generate_protocol_dic(cfg_dic,*table_info->indexes->val.integer);
        			if ( g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic != NULL || strcmp(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic, procfgdic) == 0)
        			{
        				ret = remove_protocol_docu(procfgdic);
        				memset(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic,0,STR_LEN_256);
        			}
                }
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolPowerConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLPOWERCONFIGQRXLEVMIN:
                if (table_entry && !table_entry->valid) {
                    protocolPowerConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolPowerConfigQRxLevMin =
                        table_entry->old_protocolPowerConfigQRxLevMin;
                    table_entry->old_protocolPowerConfigQRxLevMin = 0;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGPMAX:
                if (table_entry && !table_entry->valid) {
                    protocolPowerConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolPowerConfigPMax =
                        table_entry->old_protocolPowerConfigPMax;
                    table_entry->old_protocolPowerConfigPMax = 0;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGPINITRECVTARPOWER:
                if (table_entry && !table_entry->valid) {
                    protocolPowerConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->
                           protocolPowerConfigPInitRecvTarPower,
                           table_entry->
                           old_protocolPowerConfigPInitRecvTarPower,
                           sizeof(table_entry->
                                  protocolPowerConfigPInitRecvTarPower));
                    memset(table_entry->
                           old_protocolPowerConfigPInitRecvTarPower, 0,
                           sizeof(table_entry->
                                  protocolPowerConfigPInitRecvTarPower));
                    table_entry->protocolPowerConfigPInitRecvTarPower_len =
                        table_entry->
                        old_protocolPowerConfigPInitRecvTarPower_len;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMINALPUSCH:
                if (table_entry && !table_entry->valid) {
                    protocolPowerConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolPowerConfigP0NominalPUSCH =
                        table_entry->old_protocolPowerConfigP0NominalPUSCH;
                    table_entry->old_protocolPowerConfigP0NominalPUSCH = 0;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGALPHA:
                if (table_entry && !table_entry->valid) {
                    protocolPowerConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolPowerConfigAlpha,
                           table_entry->old_protocolPowerConfigAlpha,
                           sizeof(table_entry->protocolPowerConfigAlpha));
                    memset(table_entry->old_protocolPowerConfigAlpha, 0,
                           sizeof(table_entry->protocolPowerConfigAlpha));
                    table_entry->protocolPowerConfigAlpha_len =
                        table_entry->old_protocolPowerConfigAlpha_len;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMIPUCCH:
                if (table_entry && !table_entry->valid) {
                    protocolPowerConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolPowerConfigP0NomiPUCCH =
                        table_entry->old_protocolPowerConfigP0NomiPUCCH;
                    table_entry->old_protocolPowerConfigP0NomiPUCCH = 0;
                }
                break;
            case COLUMN_PROTOCOLPOWERCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    protocolPowerConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolPowerConfigRowStatus =
                        table_entry->old_protocolPowerConfigRowStatus;
                    table_entry->old_protocolPowerConfigRowStatus = 0;
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolPowerConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLPOWERCONFIGQRXLEVMIN:
            case COLUMN_PROTOCOLPOWERCONFIGPMAX:
            case COLUMN_PROTOCOLPOWERCONFIGPINITRECVTARPOWER:
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMINALPUSCH:
            case COLUMN_PROTOCOLPOWERCONFIGALPHA:
            case COLUMN_PROTOCOLPOWERCONFIGP0NOMIPUCCH:
            case COLUMN_PROTOCOLPOWERCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    table_entry->valid = 1;
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}


/** Initialize the protocolLogConfigTable table by defining its contents and how it's structured */
void
initialize_table_protocolLogConfigTable(void)
{
    const oid       protocolLogConfigTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 12001, 1, 3, 1, 4 };
    const size_t    protocolLogConfigTable_oid_len =
        OID_LENGTH(protocolLogConfigTable_oid);
    netsnmp_handler_registration *reg;
    netsnmp_iterator_info *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("protocolCommConfigInfo:init",
                "initializing table protocolLogConfigTable\n"));

    reg =
        netsnmp_create_handler_registration("protocolLogConfigTable",
                                            protocolLogConfigTable_handler,
                                            protocolLogConfigTable_oid,
                                            protocolLogConfigTable_oid_len,
                                            HANDLER_CAN_RWRITE);

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: protocolLogConfigRowStatus */
                                     0);
    table_info->min_column = COLUMN_PROTOCOLLOGCONFIGIPADDR;
    table_info->max_column = COLUMN_PROTOCOLLOGCONFIGROWSTATUS;

    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point =
        protocolLogConfigTable_get_first_data_point;
    iinfo->get_next_data_point =
        protocolLogConfigTable_get_next_data_point;
    iinfo->table_reginfo = table_info;

    netsnmp_register_table_iterator(reg, iinfo);

    /*
     * Initialise the contents of the table here 
     */
}




/*
 * create a new row in the (unsorted) table 
 */
struct protocolLogConfigTable_entry *
protocolLogConfigTable_createEntry(long protocolLogConfigRowStatus)
{
    struct protocolLogConfigTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct protocolLogConfigTable_entry);
    if (!entry)
        return NULL;

    entry->protocolLogConfigRowStatus = protocolLogConfigRowStatus;
    entry->next = protocolLogConfigTable_head;
    protocolLogConfigTable_head = entry;
    return entry;
}

/*
 * remove a row from the table 
 */
void
protocolLogConfigTable_removeEntry(struct protocolLogConfigTable_entry
                                   *entry)
{
    struct protocolLogConfigTable_entry *ptr, *prev;

    if (!entry)
        return;                 /* Nothing to remove */

    for (ptr = protocolLogConfigTable_head, prev = NULL;
         ptr != NULL; prev = ptr, ptr = ptr->next) {
        if (ptr == entry)
            break;
    }
    if (!ptr)
        return;                 /* Can't find it */

    if (prev == NULL)
        protocolLogConfigTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}


/*
 * Example iterator hook routines - using 'get_next' to do most of the work 
 */
netsnmp_variable_list *
protocolLogConfigTable_get_first_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
    *my_loop_context = protocolLogConfigTable_head;
    return protocolLogConfigTable_get_next_data_point(my_loop_context,
                                                      my_data_context,
                                                      put_index_data,
                                                      mydata);
}

netsnmp_variable_list *
protocolLogConfigTable_get_next_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
    struct protocolLogConfigTable_entry *entry =
        (struct protocolLogConfigTable_entry *) *my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if (entry) {
        snmp_set_var_typed_integer(idx, ASN_INTEGER,
                                   entry->protocolLogConfigRowStatus);
        idx = idx->next_variable;
        *my_data_context = (void *) entry;
        *my_loop_context = (void *) entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the protocolLogConfigTable table */
int
protocolLogConfigTable_handler(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    struct protocolLogConfigTable_entry *table_entry;
    struct protocolLogConfigTable_entry *table_row;
    DEBUGMSGTL(("protocolCommConfigInfo:handler",
                "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolLogConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLLOGCONFIGIPADDR:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolLogConfigIPAddr,
                                         table_entry->
                                         protocolLogConfigIPAddr_len);
                break;
            case COLUMN_PROTOCOLLOGCONFIGMACADDR:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolLogConfigMacAddr,
                                         table_entry->
                                         protocolLogConfigMacAddr_len);
                break;
            case COLUMN_PROTOCOLLOGCONFIGPORT:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         table_entry->
                                         protocolLogConfigPort,
                                         table_entry->
                                         protocolLogConfigPort_len);
                break;
            case COLUMN_PROTOCOLLOGCONFIGROWSTATUS:
                if (!table_entry) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->
                                           protocolLogConfigRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolLogConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLLOGCONFIGIPADDR:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolLogConfigIPAddr));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLLOGCONFIGMACADDR:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolLogConfigMacAddr));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLLOGCONFIGPORT:
                /*
                 * or possibly 'netsnmp_check_vb_type_and_size' 
                 */
                ret =
                    netsnmp_check_vb_type_and_max_size(request->requestvb,
                                                       ASN_OCTET_STR,
                                                       sizeof(table_entry->
                                                              protocolLogConfigPort));
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_PROTOCOLLOGCONFIGROWSTATUS:
                /*
                 * or possibly 'netsnmp_check_vb_int_range' 
                 */
                ret = netsnmp_check_vb_int(request->requestvb);
                if (ret != SNMP_ERR_NOERROR) {
                    netsnmp_set_request_error(reqinfo, request, ret);
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOTWRITABLE);
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolLogConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLLOGCONFIGIPADDR:
            case COLUMN_PROTOCOLLOGCONFIGMACADDR:
            case COLUMN_PROTOCOLLOGCONFIGPORT:
            case COLUMN_PROTOCOLLOGCONFIGROWSTATUS:
            	switch (*request->requestvb->val.integer){
            	    case RS_CREATEANDGO:
            	    case RS_CREATEANDWAIT:
            	        table_row = protocolLogConfigTable_createEntry(*table_info->indexes->val.integer);
            	        if (table_row){
            	            netsnmp_insert_iterator_context(request,table_row);

            	            //generate a new file
            	            char *procfgdic = generate_protocol_dic(cfg_dic,*table_info->indexes->val.integer);
                			if ( g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic == NULL || strcmp(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic, procfgdic) != 0)
                			{
                	            ret = generate_protocol_docu(PROTOCOL_CFG_DEFAULT, procfgdic);
                	            memcpy(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic,procfgdic,sizeof(char)*128);
                			}


            	        }
            	        else{
            	            netsnmp_set_request_error(reqinfo, request,SNMP_ERR_RESOURCEUNAVAILABLE);
            	            return SNMP_ERR_NOERROR;
            	        }
            	     break;
            	}
                break;
            }
        }
        break;

    case MODE_SET_FREE:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolLogConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLLOGCONFIGIPADDR:
            case COLUMN_PROTOCOLLOGCONFIGMACADDR:
            case COLUMN_PROTOCOLLOGCONFIGPORT:
            case COLUMN_PROTOCOLLOGCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    protocolLogConfigTable_removeEntry(table_row);
                }
                break;
            }
        }
        break;

    case MODE_SET_ACTION:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolLogConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);
            char *docpath = g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic;
            switch (table_info->colnum) {
            case COLUMN_PROTOCOLLOGCONFIGIPADDR:
                memcpy(table_entry->old_protocolLogConfigIPAddr,
                       table_entry->protocolLogConfigIPAddr,
                       sizeof(table_entry->protocolLogConfigIPAddr));
                table_entry->old_protocolLogConfigIPAddr_len =
                    table_entry->protocolLogConfigIPAddr_len;
                memset(table_entry->protocolLogConfigIPAddr, 0,
                       sizeof(table_entry->protocolLogConfigIPAddr));
                memcpy(table_entry->protocolLogConfigIPAddr,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolLogConfigIPAddr_len =
                    request->requestvb->val_len;
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, Cfg_log_ip, table_entry->protocolLogConfigIPAddr, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLLOGCONFIGMACADDR:
                memcpy(table_entry->old_protocolLogConfigMacAddr,
                       table_entry->protocolLogConfigMacAddr,
                       sizeof(table_entry->protocolLogConfigMacAddr));
                table_entry->old_protocolLogConfigMacAddr_len =
                    table_entry->protocolLogConfigMacAddr_len;
                memset(table_entry->protocolLogConfigMacAddr, 0,
                       sizeof(table_entry->protocolLogConfigMacAddr));
                memcpy(table_entry->protocolLogConfigMacAddr,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolLogConfigMacAddr_len =
                    request->requestvb->val_len;
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, Cfg_log_macaddr, table_entry->protocolLogConfigMacAddr, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLLOGCONFIGPORT:
                memcpy(table_entry->old_protocolLogConfigPort,
                       table_entry->protocolLogConfigPort,
                       sizeof(table_entry->protocolLogConfigPort));
                table_entry->old_protocolLogConfigPort_len =
                    table_entry->protocolLogConfigPort_len;
                memset(table_entry->protocolLogConfigPort, 0,
                       sizeof(table_entry->protocolLogConfigPort));
                memcpy(table_entry->protocolLogConfigPort,
                       request->requestvb->val.string,
                       request->requestvb->val_len);
                table_entry->protocolLogConfigPort_len =
                    request->requestvb->val_len;
                if (docpath)
                {
                    ret = modify_cfg_file(docpath, Cfg_log_port, table_entry->protocolLogConfigPort, OPERATE_MODIFY_VALUE, FILE_TYPE_CFG );
                }
                break;
            case COLUMN_PROTOCOLLOGCONFIGROWSTATUS:
                table_entry->old_protocolLogConfigRowStatus =
                    table_entry->protocolLogConfigRowStatus;
                table_entry->protocolLogConfigRowStatus =
                    *request->requestvb->val.integer;
                if (RS_DESTROY == table_entry->protocolLogConfigRowStatus)
                {
                	protocolLogConfigTable_removeEntry (table_entry);
                    memset(cfg_dic,0,sizeof(cfg_dic));
            		char *procfgdic = generate_protocol_dic(cfg_dic,*table_info->indexes->val.integer);
            		if ( g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic != NULL || strcmp(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic, procfgdic) == 0)
            		{
            			ret = remove_protocol_docu(procfgdic);
            			memset(g_proCfgDicTable[*table_info->indexes->val.integer-1].pro_cfg_dic,0,STR_LEN_256);
            		}
                }
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolLogConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLLOGCONFIGIPADDR:
                if (table_entry && !table_entry->valid) {
                    protocolLogConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolLogConfigIPAddr,
                           table_entry->old_protocolLogConfigIPAddr,
                           sizeof(table_entry->protocolLogConfigIPAddr));
                    memset(table_entry->old_protocolLogConfigIPAddr, 0,
                           sizeof(table_entry->protocolLogConfigIPAddr));
                    table_entry->protocolLogConfigIPAddr_len =
                        table_entry->old_protocolLogConfigIPAddr_len;
                }
                break;
            case COLUMN_PROTOCOLLOGCONFIGMACADDR:
                if (table_entry && !table_entry->valid) {
                    protocolLogConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolLogConfigMacAddr,
                           table_entry->old_protocolLogConfigMacAddr,
                           sizeof(table_entry->protocolLogConfigMacAddr));
                    memset(table_entry->old_protocolLogConfigMacAddr, 0,
                           sizeof(table_entry->protocolLogConfigMacAddr));
                    table_entry->protocolLogConfigMacAddr_len =
                        table_entry->old_protocolLogConfigMacAddr_len;
                }
                break;
            case COLUMN_PROTOCOLLOGCONFIGPORT:
                if (table_entry && !table_entry->valid) {
                    protocolLogConfigTable_removeEntry(table_row);
                } else {
                    memcpy(table_entry->protocolLogConfigPort,
                           table_entry->old_protocolLogConfigPort,
                           sizeof(table_entry->protocolLogConfigPort));
                    memset(table_entry->old_protocolLogConfigPort, 0,
                           sizeof(table_entry->protocolLogConfigPort));
                    table_entry->protocolLogConfigPort_len =
                        table_entry->old_protocolLogConfigPort_len;
                }
                break;
            case COLUMN_PROTOCOLLOGCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    protocolLogConfigTable_removeEntry(table_row);
                } else {
                    table_entry->protocolLogConfigRowStatus =
                        table_entry->old_protocolLogConfigRowStatus;
                    table_entry->old_protocolLogConfigRowStatus = 0;
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request = requests; request; request = request->next) {
            table_entry = (struct protocolLogConfigTable_entry *)
                netsnmp_extract_iterator_context(request);
            table_info = netsnmp_extract_table_info(request);

            switch (table_info->colnum) {
            case COLUMN_PROTOCOLLOGCONFIGIPADDR:
            case COLUMN_PROTOCOLLOGCONFIGMACADDR:
            case COLUMN_PROTOCOLLOGCONFIGPORT:
            case COLUMN_PROTOCOLLOGCONFIGROWSTATUS:
                if (table_entry && !table_entry->valid) {
                    table_entry->valid = 1;
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}
